using System.Collections.Generic;
using System.Linq;
using System.Text;
using WCFGenerator.SerializeGeneration.Models;

namespace WCFGenerator.SerializeGeneration.Generation
{
    public class TextMigrationPatterns
    {
        public string GenerateVersionNumberClass(int number, string className, string projectName)
        {
            var generation = new StringBuilder();
            generation.Append(
                        "//------------------------------------------------------------------------------\r\n"
                        + "// <auto-generated>\r\n"
                        + "//     This code was generated from a template.\r\n"
                        + "//\r\n"
                        + "//     Manual changes to this file may cause unexpected behavior in your application.\r\n"
                        + "//     Manual changes to this file will be overwritten if the code is regenerated.\r\n"
                        + "// </auto-generated>\r\n"
                        + "//------------------------------------------------------------------------------\r\n\r\n");
            generation.Append($"namespace {projectName}.Helpers\r\n" +
                              "{\r\n" +
                              $"\tpublic class {className} : I{className}\r\n" +
                              "\t{\r\n" +
                              $"\t\tpublic int CurrentVersion => {number};\r\n" +
                              "\t}\r\n" +
                              "}\r\n");
            return generation.ToString();
        }

        public string GenerateNewMigrationClass(string nameSpace, string className, string migrationInterface,
            int version, List<MigrationElements> migrationElements)
        {
            var generation = new StringBuilder();
            generation.Append(
                        "//------------------------------------------------------------------------------\r\n"
                        + "// <auto-generated>\r\n"
                        + "//     This code was generated from a template.\r\n"
                        + "//\r\n"
                        + "//     Manual changes to this file may cause unexpected behavior in your application.\r\n"
                        + "//     Manual changes to this file will be overwritten if the code is regenerated.\r\n"
                        + "// </auto-generated>\r\n"
                        + "//------------------------------------------------------------------------------\r\n\r\n");
            generation.Append("using Newtonsoft.Json.Linq;\r\n" +
                              $"using {nameSpace}"+ ".Infrastructure;\r\n\r\n" + 
                              $"namespace {nameSpace}\r\n" +
                              "{\r\n" +
                              $"\tpublic abstract class {className}V{version} : {migrationInterface}\r\n" +
                              "\t{\r\n" +
                              GenerateMigrationFunction(migrationElements)+
                              $"\t\tpublic int MigrationVersion => {version};\r\n" +
                              "\t}\r\n" +
                              "}\r\n");
            return generation.ToString();
        }

        private string GenerateMigrationFunction(IEnumerable<MigrationElements> migrationElements)
        {
            var stringBuilder = new StringBuilder();
            stringBuilder.Append("\t\tpublic abstract JObject Migrate(JObject oldValue);\r\n");

            foreach (var migrationElement in migrationElements)
            {
                stringBuilder.Append(GenerateMigrationChanges(migrationElement));
            }
            stringBuilder.Append("\r\n");
            return stringBuilder.ToString();
        }

        private string GenerateMigrationChanges(MigrationElements migrationElement)
        {
            var stringBuilder = new StringBuilder();
            stringBuilder.AppendFormat("\t\t\t//Changes in {0}\r\n",migrationElement.ClassNameWithNameSpace);
            stringBuilder.Append(GetCollectionChanges(migrationElement.ChangeWithPreviousProperties.Added, "Added"));
            stringBuilder.Append(GetCollectionChanges(migrationElement.ChangeWithPreviousProperties.Updated, "Updated"));
            stringBuilder.Append(GetCollectionChanges(migrationElement.ChangeWithPreviousProperties.Deleted, "Deleted"));

            return stringBuilder.ToString();
        }

        private string GetCollectionChanges(IList<GenerationProperty> changesModel, string changesName)
        {
            var stringBuilder = new StringBuilder();
            if (changesModel.Any())
            {
                stringBuilder.AppendFormat("\t\t\t//{0}:\r\n", changesName);
                foreach (var addedProperty in changesModel)
                {
                    stringBuilder.AppendFormat("\t\t\t\t//{1} {0}\r\n", addedProperty.Name, addedProperty.Type);
                }
            }
            return stringBuilder.ToString();
        }
    }
}
