<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.AnalyzerUtilities</name>
    </assembly>
    <members>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.Count``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns the number of elements in a sequence.
            </summary>
            <typeparam name="TSource">he type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <returns>The number of elements in the input sequence.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.HasExactly``1(System.Collections.Immutable.ImmutableArray{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains, exactly, <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains, exactly, <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.HasMoreThan``1(System.Collections.Immutable.ImmutableArray{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains more than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains more than <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.HasFewerThan``1(System.Collections.Immutable.ImmutableArray{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains fewer than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains less then <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.Any``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,System.Boolean},``1)">
            <summary>
            Determines whether a sequence contains any elements.
            </summary>
            <typeparam name="T">The type of the elements of array.</typeparam>
            <typeparam name="TArg">The type of arg.</typeparam>
            <param name="array">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> whose elements to apply the predicate to.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <param name="arg">The argument to pass into the predicate.</param>
            <returns> true if any elements in the source sequence pass the test in the specified predicate otherwise, false.</returns>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="obj">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="obj">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1">
            <summary>
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> that can be recycled via an object pool.
            </summary>
        </member>
        <member name="P:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Count">
            <summary>
            Obtain the number of elements in the set.
            </summary>
            <returns>The number of elements in the set.</returns>
        </member>
        <member name="P:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.IsEmpty">
            <summary>
            Determine whether the set is empty.</summary>
            <returns>true if the set is empty; otherwise, false.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Add(`0)">
            <summary>
            Attempts to add a <paramref name="value"/> to the set.
            </summary>
            <param name="value">The value to add.</param>
            <returns>true if the value was added to the set. If the value already exists, this method returns false.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the given <paramref name="values"/> to the set.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Remove(`0)">
            <summary>
            Attempts to remove a value from the set.
            </summary>
            <param name="item">The value to remove.</param>
            <returns>true if the value was removed successfully; otherwise false.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Clear">
            <summary>
            Clears all the elements from the set.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Contains(`0)">
            <summary>
            Returns true if the given <paramref name="item"/> is present in the set.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.GetEnumerator">
            <summary>
            Obtain an enumerator that iterates through the elements in the set.
            </summary>
            <returns>An enumerator for the set.</returns>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.PooledConcurrentDictionary`2">
            <summary>
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> that can be recycled via an object pool.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value"/> to slot <paramref name="index"/>.
            Fills in unallocated slots preceding the <paramref name="index"/>, if any.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ObjectPool`1.Free(`0,System.Threading.CancellationToken)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1">
            <summary>
            Pooled <see cref="T:System.Collections.Generic.SortedSet`1"/>.
            </summary>
            <typeparam name="T">Type of elements in the set.</typeparam>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledSortedSet`1.GetInstance(System.Collections.Generic.IComparer{`0})">
            <summary>
            Gets a pooled instance of a <see cref="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1"/> with an optional comparer.
            </summary>
            <param name="comparer">Singleton (or at least a bounded number) comparer to use, or null for the element type's default comparer.</param>
            <returns>An empty <see cref="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1"/>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledSortedSet`1.GetInstance(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Gets a pooled instance of a <see cref="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1"/> with the given initializer and an optional comparer.
            </summary>
            <param name="initializer">Initializer for the set.</param>
            <param name="comparer">Comparer to use, or null for the element type's default comparer.</param>
            <returns>An empty <see cref="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1"/>.</returns>
        </member>
        <member name="T:Analyzer.Utilities.AdditionalFileProvider">
            <summary>
            Provider that allows analyzers to easily find and use
            <see href="https://github.com/dotnet/roslyn/blob/main/docs/analyzers/Using%20Additional%20Files.md">additional files</see>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.AdditionalFileProvider.FromOptions(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions)">
            <summary>
            Creates an instance of this provider from the specified <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions"/>.
            </summary>
            <param name="options">Options passed to a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>.</param>
            <returns>An instance of <see cref="T:Analyzer.Utilities.AdditionalFileProvider"/>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.AdditionalFileProvider.GetFile(System.String)">
            <summary>
            Returns the first additional file whose name is the specified <paramref name="fileName"/>.
            </summary>
            <param name="fileName">Name of the file, including extension, to return.</param>
            <returns>An additional file or <c>null</c> if no file can be found.</returns>
        </member>
        <member name="M:Analyzer.Utilities.AdditionalFileProvider.GetMatchingFiles(System.String)">
            <summary>
            Returns all additional files whose names match the specified <paramref name="pattern"/>.
            </summary>
            <param name="pattern">A regular expression.</param>
            <returns>An enumeration of additional files whose names match the pattern.</returns>
        </member>
        <member name="T:Analyzer.Utilities.BoundedCacheWithFactory`2">
            <summary>
            Provides bounded cache for analyzers.
            Acts as a good alternative to <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/>
            when the cached value has a cyclic reference to the key preventing early garbage collection of entries.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.RoslynDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/>
        </member>
        <member name="M:Analyzer.Utilities.RoslynDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="T:Analyzer.Utilities.DoNotCatchGeneralUnlessRethrownAnalyzer.DisallowGeneralCatchUnlessRethrowWalker">
            <summary>
            Walks an IOperation tree to find catch blocks that handle general types without rethrowing them.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Extensions.CompilationExtensions">
            <summary>
            Provides extensions to <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.IsWebProject(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions)">
            <summary>
            Gets a value indicating whether the project of the compilation is a Web SDK project based on project properties.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.GetOrCreateTypeByMetadataName(Microsoft.CodeAnalysis.Compilation,System.String)">
            <summary>
            Gets a type by its full type name and cache it at the compilation level.
            </summary>
            <param name="compilation">The compilation.</param>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> if found, null otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.TryGetOrCreateTypeByMetadataName(Microsoft.CodeAnalysis.Compilation,System.String,Microsoft.CodeAnalysis.INamedTypeSymbol@)">
            <summary>
            Gets a type by its full type name and cache it at the compilation level.
            </summary>
            <param name="compilation">The compilation.</param>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> if found, null otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.TargetsDotNetFramework(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets a value indicating, whether the compilation of assembly targets .NET Framework.
            This method differentiates between .NET Framework and other frameworks (.NET Core, .NET Standard, .NET 5 in future).
            </summary>
            <param name="compilation">The compilation</param>
            <returns><c>True</c> if the compilation targets .NET Framework; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IPropertySymbolExtensions.IsAutoProperty(Microsoft.CodeAnalysis.IPropertySymbol)">
            <summary>
            Check if a property is an auto-property.
            TODO: Remove this helper when https://github.com/dotnet/roslyn/issues/46682 is handled.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion1">
            <summary>
            This will only compile if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> and <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> have the
            same value.
            </summary>
            <remarks>
            <para>The subtraction in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion1"/> will overflow if <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> is greater, and the conversion
            to an unsigned value after negation in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion2"/> will overflow if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> is greater.</para>
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion2">
            <summary>
            This will only compile if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> and <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> have the
            same value.
            </summary>
            <remarks>
            <para>The subtraction in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion1"/> will overflow if <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> is greater, and the conversion
            to an unsigned value after negation in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion2"/> will overflow if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> is greater.</para>
            </remarks>
        </member>
        <member name="T:Analyzer.Utilities.Extensions.SourceTextExtensions">
            <summary>
            Class that contains extensions to <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.SourceTextExtensions.Parse``1(Microsoft.CodeAnalysis.Text.SourceText,System.Func{System.IO.StreamReader,``0})">
            <summary>
            Reads the <paramref name="text"/> contents into a stream and returns the result of calling the
            <paramref name="parser"/> function on that stream.
            </summary>
            <typeparam name="T">Type to deserialize from the <paramref name="text"/>.</typeparam>
            <param name="text">Abstraction for an additional file's contents.</param>
            <param name="parser">Function that will parse <paramref name="text"/> into <typeparamref name="T"/>.</param>
            <returns>Output from <paramref name="parser"/>.</returns>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.DiagnosticExtensions.s_syntaxTreeDiagnosticOptionsProperty">
            <summary>
            TODO: Revert this reflection based workaround once we move to Microsoft.CodeAnalysis version 3.0
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableExtensions.HasExactly``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains, exactly, <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains, exactly, <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableExtensions.HasMoreThan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains more than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains more than <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableExtensions.HasFewerThan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains fewer than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains less than <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.WhereMethodDoesNotContainAttribute(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Excludes <paramref name="methods"/> that have an attribute that precisely matches <paramref name="attributeType"/>.
            </summary>
            <param name="methods">List of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> to filter.</param>
            <param name="attributeType">The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> of the attribute class to search.</param>
            <returns>A filtered list of methods.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetMethodOverloadsWithDesiredParameterAtLeadingOrTrailing(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean)">
            <summary>
            Returns a list of method symbols from a given list of the method symbols, which has its parameter type as
            expectedParameterType as its first parameter or the last parameter in addition to matching all the other 
            parameter types of the selectedOverload method symbol
            </summary>
            <param name="methods">List of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> to scan for possible overloads</param>
            <param name="selectedOverload"><see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> that is currently picked by the user</param>
            <param name="expectedParameterType"><see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> type of the leading parameter or the trailing parameter</param>
            <param name="trailingOnly"><see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> If the expected parameter should appear at the trailing position of the parameter list of the method overload</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetMethodOverloadsWithDesiredParameterAtTrailing(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a list of method symbols from a given list of the method symbols, which has its parameter type as
            expectedParameterType as its last parameter in addition to matching all the other parameter types of the 
            selectedOverload method symbol
            </summary>
            <param name="methods">List of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> to scan for possible overloads</param>
            <param name="selectedOverload"><see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> that is currently picked by the user</param>
            <param name="expectedTrailingParameterType"><see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> type of the leading parameter or the trailing parameter</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetFirstOrDefaultMemberWithParameterTypes(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.ITypeSymbol[])">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> in the sequence who's parameters match <paramref name="expectedParameterTypesInOrder"/>.
            </summary>
            <param name="members">The sequence of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>s to search.</param>
            <param name="expectedParameterTypesInOrder">The types of the parameters, in order.</param>
            <returns>
            The first <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> in the sequence who's parameters match <paramref name="expectedParameterTypesInOrder"/>, or <langword>null</langword> if
            no method was found.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetFirstOrDefaultMemberWithParameterInfos(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Analyzer.Utilities.Extensions.ParameterInfo[])">
            <summary>
            Given a <see cref="T:System.Collections.Generic.IEnumerable`1"/>, this method returns the method symbol which 
            matches the expectedParameterTypesInOrder parameter requirement
            </summary>
            <param name="members"></param>
            <param name="expectedParameterTypesInOrder"></param>
            <returns></returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetFirstOrDefaultMemberWithParameterTypes(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ITypeSymbol})">
            <summary>
            Given an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, returns the <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> whose parameter list
            matches <paramref name="expectedParameterTypesInOrder"/>.
            </summary>
            <param name="members"></param>
            <param name="expectedParameterTypesInOrder">Expected types of the member's parameters.</param>
            <returns>
            The first member in the sequence whose parameters match <paramref name="expectedParameterTypesInOrder"/>, 
            or null if no matches are found.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsObjectEqualsOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsObjectEquals(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method is <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsStaticObjectEqualsOrReferenceEquals(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given <paramref name="method"/> is <see cref="M:System.Object.Equals(System.Object,System.Object)"/> or <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsGetHashCodeOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides Object.GetHashCode.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsToStringOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides Object.ToString.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsObjectMethodOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides a method from System.Object
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsFinalizer(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method is a Finalizer implementation.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsImplementationOfInterfaceMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.String)">
            <summary>
            Checks if the given method is an implementation of the given interface method
            Substituted with the given typeargument.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Checks if the given method implements IDisposable.Dispose()
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsAsyncDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Checks if the given method implements IAsyncDisposable.Dispose()
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method implements <see cref="M:System.IDisposable.Dispose"/> or overrides an implementation of <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsAsyncDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method implements "IAsyncDisposable.Dispose" or overrides an implementation of "IAsyncDisposable.Dispose".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Dispose()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeSignatureByConvention(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method matches Dispose method convention and can be recognized by "using".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeBoolMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Dispose(bool)".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeCloseMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Close()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeCloseAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method has the signature "Task CloseAsync()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method has the signature "Task DisposeAsync()" or "ValueTask DisposeAsync()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasOverriddenDisposeCoreAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method has the signature "override Task DisposeCoreAsync(bool)".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.GetDisposeMethodKind(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the <see cref="T:Analyzer.Utilities.DisposeMethodKind"/> for the given method.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.GetDisposeMethodKind(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets the <see cref="T:Analyzer.Utilities.DisposeMethodKind"/> for the given method.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsOnDeserializationImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method implements 'System.Runtime.Serialization.IDeserializationCallback.OnDeserialization' or overrides an implementation of 'System.Runtime.Serialization.IDeserializationCallback.OnDeserialization'/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsPropertyGetter(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is a property getter.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsIndexerGetter(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is the getter for an indexer.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsPropertyAccessor(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is an accessor for a property.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsEventAccessor(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is an accessor for an event.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_collectionAddMethodNameVariants">
            <summary>
            Set of well-known collection add method names.
            Used in <see cref="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsCollectionAddMethod(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.INamedTypeSymbol})"/> heuristic.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsCollectionAddMethod(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Determine if the specific method is an Add method that adds to a collection.
            </summary>
            <param name="method">The method to test.</param>
            <param name="iCollectionTypes">Collection types.</param>
            <returns>'true' if <paramref name="method"/> is believed to be the add method of a collection.</returns>
            <remarks>
            We use the following heuristic to determine if a method is a collection add method:
            1. Method's enclosing type implements any of the given <paramref name="iCollectionTypes"/>.
            2. Any of the following name heuristics are met:
                a. Method's name is from one of the well-known add method names from <see cref="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_collectionAddMethodNameVariants"/> ("Add", "AddOrUpdate", "GetOrAdd", "TryAdd", or "TryUpdate")
                b. Method's name begins with "Add" (FxCop compat)
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsTaskFromResultMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determine if the specific method is a Task.FromResult method that wraps a result in a task.
            </summary>
            <param name="method">The method to test.</param>
            <param name="taskType">Task type.</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsTaskConfigureAwaitMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determine if the specific method is a Task.ConfigureAwait(bool) method.
            </summary>
            <param name="method">The method to test.</param>
            <param name="genericTaskType">Generic task type.</param>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_methodToTopmostOperationBlockCache">
            <summary>
            PERF: Cache from method symbols to their topmost block operations to enable interprocedural flow analysis
            across analyzers and analyzer callbacks to re-use the operations, semanticModel and control flow graph.
            </summary>
            <remarks>Also see <see cref="F:Analyzer.Utilities.Extensions.IOperationExtensions.s_operationToCfgCache"/></remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.GetTopmostOperationBlock(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Returns the topmost <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation"/> for given <paramref name="method"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasEventHandlerSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns true for void returning methods with two parameters, where
            the first parameter is of <see cref="T:System.Object"/> type and the second
            parameter inherits from or equals <see cref="T:System.EventArgs"/> type or
            whose name ends with 'EventArgs'.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsOverrideOrVirtualMethodOf(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Find out if the method overrides from target virtual method of a certain type
            or it is the virtual method itself.
            </summary>
            <param name="methodSymbol">The method</param>
            <param name="typeSymbol">The type has virtual method</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsArgumentNullCheckMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns true if this is a bool returning static method whose name starts with "IsNull"
            with a single parameter whose type is not a value type.
            For example, "static bool string.IsNullOrEmpty()"
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsAutoPropertyAccessor(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check if a method is an auto-property accessor.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsTopLevelStatementsEntryPointMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check if the given <paramref name="methodSymbol"/> is an implicitly generated method for top level statements.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.DerivesFromOrImplementsAnyConstructionOf(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether <paramref name="type"/> derives from, or implements
            any generic construction of, the type defined by <paramref name="parentType"/>.
            </summary>
            <remarks>
            This method only works when <paramref name="parentType"/> is a definition,
            not a constructed type.
            </remarks>
            <example>
            <para>
            If <paramref name="parentType"/> is the class <see cref="T:System.Collections.Generic.Stack`1"/>, then this
            method will return <see langword="true"/> when called on <c>Stack&gt;int></c>
            or any type derived it, because <c>Stack&gt;int></c> is constructed from
            <see cref="T:System.Collections.Generic.Stack`1"/>.
            </para>
            <para>
            Similarly, if <paramref name="parentType"/> is the interface <see cref="T:System.Collections.Generic.IList`1"/>,
            then this method will return <see langword="true"/> for <c>List&gt;int></c>
            or any other class that extends <see cref="T:System.Collections.Generic.IList`1"/> or an class that implements it,
            because <c>IList&gt;int></c> is constructed from <see cref="T:System.Collections.Generic.IList`1"/>.
            </para>
            </example>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.ImplementsEqualityOperators(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified type implements both the
            equality and inequality operators.
            </summary>
            <param name="symbol">
            A symbols specifying the type to examine.
            </param>
            <returns>
            true if the type specified by <paramref name="symbol"/> implements both the
            equality and inequality operators, otherwise false.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsStaticHolderType(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified symbol is a static
            holder type.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> is a static holder type;
            otherwise <see langword="false"/>.
            </returns>
            <remarks>
            A symbol is a static holder type if it is a class with at least one
            "qualifying member" (<see cref="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsQualifyingMember(Microsoft.CodeAnalysis.ISymbol)"/>) and no
            "disqualifying members" (<see cref="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsDisqualifyingMember(Microsoft.CodeAnalysis.ISymbol)"/>).
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsQualifyingMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns a value indicating whether the specified symbol qualifies as a
            member of a static holder class.
            </summary>
            <param name="member">
            The member being examined.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="member"/> qualifies as a member of
            a static holder class; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsDisqualifyingMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns a value indicating whether the presence of the specified symbol
            disqualifies a class from being considered a static holder class.
            </summary>
            <param name="member">
            The member being examined.
            </param>
            <returns>
            <see langword="true"/> if the presence of <paramref name="member"/> disqualifies the
            current type as a static holder class; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsTopLevelStatementsEntryPointType(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Check if the given <paramref name="typeSymbol"/> is an implicitly generated type for top level statements.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetReceiverType(Microsoft.CodeAnalysis.Operations.IInvocationOperation,Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the receiver type for an invocation expression (i.e. type of 'A' in invocation 'A.B()')
            If the invocation actually involves a conversion from A to some other type, say 'C', on which B is invoked,
            then this method returns type A if <paramref name="beforeConversion"/> is true, and C if false.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WithoutFullyImplicitOperations(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IOperation})">
            <summary>
            Filters out operations that are implicit and have no explicit descendant with a constant value or a non-null type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetTopmostExplicitDescendants(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Gets explicit descendants or self of the given <paramref name="operation"/> that have no explicit ancestor in
            the operation tree rooted at <paramref name="operation"/>.
            </summary>
            <param name="operation">Operation</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsOperationNoneRoot(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            True if this operation has no IOperation API support, i.e. <see cref="F:Microsoft.CodeAnalysis.OperationKind.None"/> and
            is the root operation, i.e. <see cref="P:Microsoft.CodeAnalysis.Operation.Parent"/> is null.
            For example, this returns true for attribute operations.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetTopmostParentBlock(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns the topmost <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation"/> containing the given <paramref name="operation"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetFirstParentBlock(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns the first <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation"/> in the parent chain of <paramref name="operation"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetAncestor``1(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.OperationKind,System.Func{``0,System.Boolean})">
            <summary>
            Gets the first ancestor of this operation with:
             1. Specified OperationKind
             2. If <paramref name="predicate"/> is non-null, it succeeds for the ancestor.
            Returns null if there is no such ancestor.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetAncestor(Microsoft.CodeAnalysis.IOperation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.OperationKind},System.Func{Microsoft.CodeAnalysis.IOperation,System.Boolean})">
            <summary>
            Gets the first ancestor of this operation with:
             1. Any OperationKind from the specified <paramref name="ancestorKinds"/>.
             2. If <paramref name="predicate"/> is non-null, it succeeds for the ancestor.
            Returns null if there is no such ancestor.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetInstance(Microsoft.CodeAnalysis.Operations.IInstanceReferenceOperation,System.Boolean)">
            <summary>
            Gets the operation for the object being created that is being referenced by <paramref name="operation"/>.
            If the operation is referencing an implicit or an explicit this/base/Me/MyBase/MyClass instance, then we return "null".
            </summary>
            <param name="operation"></param>
            <param name="isInsideAnonymousObjectInitializer">Flag to indicate if the operation is a descendant of an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousObjectCreationOperation"/>.</param>
            <remarks>
            PERF: Note that the parameter <paramref name="isInsideAnonymousObjectInitializer"/> is to improve performance by avoiding walking the entire IOperation parent for non-initializer cases.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsComparisonOperator(Microsoft.CodeAnalysis.Operations.IBinaryOperation)">
            <summary>
            Indicates if the given <paramref name="binaryOperation"/> is a predicate operation used in a condition.
            </summary>
            <param name="binaryOperation"></param>
            <returns></returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsAdditionOrSubstractionOperation(Microsoft.CodeAnalysis.Operations.IBinaryOperation,System.Char@)">
            <summary>
            Indicates if the given <paramref name="binaryOperation"/> is an addition or substaction operation.
            </summary>
            <param name="binaryOperation"></param>
            <returns>true if the operation is addition or substruction</returns>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.IOperationExtensions.s_operationToCfgCache">
            <summary>
            PERF: Cache from operation roots to their corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> to enable interprocedural flow analysis
            across analyzers and analyzer callbacks to re-use the control flow graph.
            </summary>
            <remarks>Also see <see cref="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_methodToTopmostOperationBlockCache"/></remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetCaptures(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Gets the symbols captured from the enclosing function(s) by the given lambda or local function.
            </summary>
            <param name="operation">Operation representing the lambda or local function.</param>
            <param name="lambdaOrLocalFunction">Method symbol for the lambda or local function.</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.TryGetParentTupleOperation(Microsoft.CodeAnalysis.Operations.ITupleOperation,Microsoft.CodeAnalysis.Operations.ITupleOperation@,Microsoft.CodeAnalysis.IOperation@)">
            <summary>
            If the given <paramref name="tupleOperation"/> is a nested tuple,
            gets the parenting tuple operation and the tuple element of that parenting tuple
            which contains the given tupleOperation as a descendant operation.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WalkDownParentheses(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Walks down consecutive parenthesized operations until an operand is reached that isn't a parenthesized operation.
            </summary>
            <param name="operation">The starting operation.</param>
            <returns>The inner non parenthesized operation or the starting operation if it wasn't a parenthesized operation.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WalkDownConversion(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Walks down consecutive conversion operations until an operand is reached that isn't a conversion operation.
            </summary>
            <param name="operation">The starting operation.</param>
            <returns>The inner non conversion operation or the starting operation if it wasn't a conversion operation.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WalkDownConversion(Microsoft.CodeAnalysis.IOperation,System.Func{Microsoft.CodeAnalysis.Operations.IConversionOperation,System.Boolean})">
            <summary>
            Walks down consecutive conversion operations that satisfy <paramref name="predicate"/> until an operand is reached that
            either isn't a conversion or doesn't satisfy <paramref name="predicate"/>.
            </summary>
            <param name="operation">The starting operation.</param>
            <param name="predicate">A predicate to filter conversion operations.</param>
            <returns>The first operation that either isn't a conversion or doesn't satisfy <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.HasArgument``1(Microsoft.CodeAnalysis.Operations.IInvocationOperation,``0@)">
            <summary>
            Determines if the one of the invocation's arguments' values is an argument of the specified type, and if so, find
            the first one.
            </summary>
            <param name="invocationOperation">Invocation operation whose arguments to look through.</param>
            <param name="firstFoundArgument">First found IArgumentOperation.Value of the specified type, order by the method's
            signature's parameters (as opposed to how arguments are specified when invoked).</param>
            <returns>True if one is found, false otherwise.</returns>
            <remarks>
            IInvocationOperation.Arguments are ordered by how they are specified, which may differ from the order in the method
            signature if the caller specifies arguments by name. This will find the first typeof operation ordered by the
            method signature's parameters.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetArgumentsInParameterOrder(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Operations.IArgumentOperation})">
            <summary>
            Useful when named arguments used for a method call and you need them in the original parameter order.
            </summary>
            <param name="arguments">Arguments of the method</param>
            <returns>Returns the arguments in parameter order</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetValueUsageInfo(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns the <see cref="T:Analyzer.Utilities.ValueUsageInfo"/> for the given operation.
            This extension can be removed once https://github.com/dotnet/roslyn/issues/25057 is implemented.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsAnyCompoundAssignment(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns true if the given operation is a regular compound assignment,
            i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation"/> such as <code>a += b</code>,
            or a special null coalescing compound assignment, i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICoalesceAssignmentOperation"/>
            such as <code>a ??= b</code>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsBackingFieldForProperty(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IPropertySymbol@)">
            <summary>
            Determines if the given symbol is a backing field for a property.
            </summary>
            <param name="symbol">This symbol to check.</param>
            <param name="propertySymbol">The property that this field symbol is backing.</param>
            <returns>True if the given symbol is a backing field for a property, false otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsExternallyVisible(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            True if the symbol is externally visible outside this assembly.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.FormatMemberName(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Format member names in a way consistent with FxCop's display format.
            </summary>
            <param name="member"></param>
            <returns>
            A string representing the name of the member in a format consistent with FxCop.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ContainsParameterOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Check whether given parameters contains any parameter with given type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetParametersOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Get parameters which type is the given type
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetParametersOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Gets the parameters whose type is equal to the given special type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasOverloadWithParameterOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Check whether given overloads has any overload whose parameters has the given type as its parameter type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetParameterIndices(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},System.Threading.CancellationToken)">
            <summary>
            Convert given parameters to the indices to the given method's parameter list.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ParametersAreSame(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check whether parameter count and parameter types of the given methods are same.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ParameterTypesAreSame(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Check whether parameter types of the given methods are same for given parameter indices.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ReturnTypeAndParametersAreSame(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check whether return type, parameters count and parameter types are same for the given methods.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsFromMscorlib(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Check whether given symbol is from mscorlib
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetMatchingOverload(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},System.Int32,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Get overload from the given overloads that matches given method signature + given parameter
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyInterfaceMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member implicitly or explicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyImplicitInterfaceMember``1(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member implicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyImplicitInterfaceMember``1(Microsoft.CodeAnalysis.ISymbol,``0@)">
            <summary>
            Checks if a given symbol implements an interface member implicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsOverrideOrImplementationOfInterfaceMember(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member or overrides an implementation of an interface member.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetOverriddenMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the symbol overridden by the given <paramref name="symbol"/>.
            </summary>
            <remarks>Requires that <see cref="P:Microsoft.CodeAnalysis.ISymbol.IsOverride"/> is true for the given <paramref name="symbol"/>.</remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyExplicitInterfaceMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member explicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasAttribute(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified symbol has the specified
            attribute.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <param name="attribute">
            The attribute in question.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> has an attribute of type
            <paramref name="attribute"/>; otherwise <see langword="false"/>.
            </returns>
            <remarks>
            If <paramref name="symbol"/> is a type, this method does not find attributes
            on its base types.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasDerivedTypeAttribute(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified or inherited symbol has the specified
            attribute.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <param name="attribute">
            The attribute in question.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> has an attribute of type
            <paramref name="attribute"/>; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasDerivedMethodAttribute(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified or inherited method symbol has the specified
            attribute.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <param name="attribute">
            The attribute in question.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> has an attribute of type
            <paramref name="attribute"/>; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasAttributes(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol[])">
            <summary>
            Determines if the given symbol has the specified attributes.
            </summary>
            <param name="symbol">Symbol to examine.</param>
            <param name="attributes">Type symbols of the attributes to check for.</param>
            <returns>Boolean array, same size and order as <paramref name="attributes"/>, indicating that the corresponding
            attribute is present.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetAttributes(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets enumeration of attributes that are of the specified type.
            </summary>
            <param name="symbol">This symbol whose attributes to get.</param>
            <param name="attributeType">Type of attribute to look for.</param>
            <returns>Enumeration of attributes.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsInSource(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Indicates if a symbol has at least one location in source.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsSymbolWithSpecialDiscardName(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true for symbols whose name starts with an underscore and
            are optionally followed by an integer, such as '_', '_1', '_2', etc.
            These symbols can be treated as special discard symbol names.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ITypeSymbolExtensions.IsDisposable(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Indicates if the given <paramref name="type"/> is disposable,
            and thus can be used in a <code>using</code> or <code>await using</code> statement.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ITypeSymbolExtensions.GetApplicableAttributes(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets all attributes directly applied to the type or inherited from a base type.
            </summary>
            <param name="type">The type symbol.</param>
            <param name="attributeUsageAttribute">The compilation symbol for <see cref="T:System.AttributeUsageAttribute"/>.</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ITypeSymbolExtensions.HasAnyCollectionCountProperty(Microsoft.CodeAnalysis.ITypeSymbol,Analyzer.Utilities.WellKnownTypeProvider)">
            <summary>
            Checks whether the current type contains one of the following count property:
                - <see cref="P:System.Collections.ICollection.Count"/>
                - <see cref="P:System.Collections.Generic.ICollection`1.Count"/>
                - <see cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
            </summary>
            <param name="invocationTarget">The type to check</param>
            <param name="wellKnownTypeProvider">An instance of the <see cref="T:Analyzer.Utilities.WellKnownTypeProvider"/> used to access the three described known types.</param>
            <returns><c>true</c> when the type contains one of the supported collection count property; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Analyzer.Utilities.Extensions.SymbolVisibilityExtensions">
            <summary>
            Extensions for <see cref="T:Analyzer.Utilities.Extensions.SymbolVisibility"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.SymbolVisibilityExtensions.IsAtLeastAsVisibleAs(Analyzer.Utilities.Extensions.SymbolVisibility,Analyzer.Utilities.Extensions.SymbolVisibility)">
            <summary>
            Determines whether <paramref name="typeVisibility"/> is at least as visible as <paramref name="comparisonVisibility"/>.
            </summary>
            <param name="typeVisibility">The visibility to compare against.</param>
            <param name="comparisonVisibility">The visibility to compare with.</param>
            <returns>True if one can say that <paramref name="typeVisibility"/> is at least as visible as <paramref name="comparisonVisibility"/>.</returns>
            <remarks>
            For example, <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Public"/> is at least as visible as <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Internal"/>, but <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Private"/> is not as visible as <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Public"/>.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ListExtensions.ExtractAll``2(System.Collections.Generic.List{``0},System.Func{``0,``1,System.Boolean},``1)">
            <summary>
            Extract and remove all elements from <paramref name="list"/> which are matched by
            <paramref name="predicate"/>.
            </summary>
            <typeparam name="T">The type of element in the list.</typeparam>
            <typeparam name="TArg">A state argument to pass to <paramref name="predicate"/>.</typeparam>
            <param name="list">The list.</param>
            <param name="predicate">A predicate matching elements to remove from <paramref name="list"/>.</param>
            <param name="argument">An additional state argument to pass to <paramref name="predicate"/>.</param>
            <returns>A collection of elements removed from <paramref name="list"/>, in the order they were removed. If
            no elements were removed, this method returns <see cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/>.</returns>
        </member>
        <member name="T:Analyzer.Utilities.DisposeMethodKind">
            <summary>
            Describes different kinds of Dispose-like methods.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.None">
            <summary>
            Not a dispose-like method.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.Dispose">
            <summary>
            An override of <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.DisposeBool">
            <summary>
            A virtual method named Dispose that takes a single Boolean parameter, as
            is used when implementing the standard Dispose pattern.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.DisposeAsync">
            <summary>
            A method named DisposeAsync that has no parameters and returns Task.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.DisposeCoreAsync">
            <summary>
            An overridden method named DisposeCoreAsync that takes a single Boolean parameter and returns Task, as
            is used when implementing the standard DisposeAsync pattern.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.Close">
            <summary>
            A method named Close on a type that implements <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.CloseAsync">
            <summary>
            A method named CloseAsync that has no parameters and returns Task.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Lightup.NullableAnnotation">
            <summary>
            Represents the nullability of values that can be assigned
            to an expression used as an lvalue.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableAnnotation.None">
            <summary>
            The expression has not been analyzed, or the syntax is
            not an expression (such as a statement).
            </summary>
            <remarks>
            There are a few different reasons the expression could
            have not been analyzed:
                1) The symbol producing the expression comes from
                   a method that has not been annotated, such as
                   invoking a C# 7.3 or earlier method, or a
                   method in this compilation that is in a disabled
                   context.
                2) Nullable is completely disabled in this
                   compilation.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableAnnotation.NotAnnotated">
            <summary>
            The expression is not annotated (does not have a ?).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableAnnotation.Annotated">
            <summary>
            The expression is annotated (does have a ?).
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Lightup.NullableContext">
            <summary>
            Represents the state of the nullable analysis at a specific point in a file. Bits one and
            two correspond to whether the nullable feature is enabled. Bits three and four correspond
            to whether the context was inherited from the global context.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.Disabled">
            <summary>
            Nullable warnings and annotations are explicitly turned off at this location.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.WarningsEnabled">
            <summary>
            Nullable warnings are enabled and will be reported at this file location.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.AnnotationsEnabled">
            <summary>
            Nullable annotations are enabled and will be shown when APIs defined at
            this location are used in other contexts.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.Enabled">
            <summary>
            The nullable feature is fully enabled.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.WarningsContextInherited">
            <summary>
            The nullable warning state is inherited from the project default.
            </summary>
            <remarks>
            The project default can change depending on the file type. Generated
            files have nullable off by default, regardless of the project-level
            default setting.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.AnnotationsContextInherited">
            <summary>
            The nullable annotation state is inherited from the project default.
            </summary>
            <remarks>
            The project default can change depending on the file type. Generated
            files have nullable off by default, regardless of the project-level
            default setting.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.ContextInherited">
             <summary>
             The current state of both warnings and annotations are inherited from
             the project default.
             </summary>
             <remarks>
             This flag is set by default at the start of all files.
            
             The project default can change depending on the file type. Generated
             files have nullable off by default, regardless of the project-level
             default setting.
             </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.WarningsEnabled(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether nullable warnings are enabled for this context.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.AnnotationsEnabled(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether nullable annotations are enabled for this context.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.WarningsInherited(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether the nullable warning state was inherited from the project default for this file type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.AnnotationsInherited(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether the nullable annotation state was inherited from the project default for this file type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.OperationWrapperHelper.GetWrappedType(System.Type)">
            <summary>
            Gets the type that is wrapped by the given wrapper.
            </summary>
            <param name = "wrapperType">Type of the wrapper for which the wrapped type should be retrieved.</param>
            <returns>The wrapped type, or <see langword="null"/> if there is no info.</returns>
        </member>
        <member name="T:Analyzer.Utilities.MSBuildItemOptionNames">
            <summary>
            MSBuild item names that are required to be threaded as analyzer config options.
            The analyzer config option will have the following key/value:
            - Key: Item name prefixed with an '_' and suffixed with a 'List' to reduce chances of conflicts with any existing project property.
            - Value: Concatenated item metadata values, separated by a ',' character. See https://github.com/dotnet/sdk/issues/12706#issuecomment-668219422 for details.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.OptionKind">
            <summary>
            Kind of option to fetch from <see cref="T:Analyzer.Utilities.ICategorizedAnalyzerConfigOptions"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.OptionKind.DotnetCodeQuality">
            <summary>
            Option prefixed with <c>dotnet_code_quality.</c>.
            <para>Used for custom analyzer config options for analyzers in this repo.</para>
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.OptionKind.BuildProperty">
            <summary>
            Option prefixed with <c>build_property.</c>.
            <para>Used for options generated for MSBuild properties.</para>
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.MSBuildPropertyOptionNames">
            <summary>
            MSBuild property names that are required to be threaded as analyzer config options.
            </summary>
            <remarks>const fields in this type are automatically discovered and used to generate build_properties entries in the generated .globalconfig</remarks>
        </member>
        <member name="T:Analyzer.Utilities.SyntaxTreeCategorizedAnalyzerConfigOptions">
            <summary>
            Analyzer configuration options for a given syntax tree from <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions"/>
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.ICategorizedAnalyzerConfigOptions">
             <summary>
             Analyzer configuration options that are parsed into general and specific configuration options.
            
             <para><strong>.editorconfig</strong> format:</para>
             <list type="number">
             <item><description>General configuration option:
             <list type="number">
             <item><description><c>dotnet_code_quality.<em>OptionName</em> = <em>OptionValue</em></c></description></item>
             </list>
             </description></item>
             <item><description>Specific configuration option:
             <list type="number">
             <item><description><c>dotnet_code_quality.<em>RuleId</em>.<em>OptionName</em> = <em>OptionValue</em></c></description></item>
             <item><description><c>dotnet_code_quality.<em>RuleCategory</em>.<em>OptionName</em> = <em>OptionValue</em></c></description></item>
             </list>
             </description></item>
             </list>
            
             <para><strong>.editorconfig</strong> examples to configure API surface analyzed by analyzers:</para>
             <list type="number">
             <item><description>General configuration option:
             <list type="number">
             <item><description><c>dotnet_code_quality.api_surface = all</c></description></item>
             </list>
             </description></item>
             <item><description>Specific configuration option:
             <list type="number">
             <item><description><c>dotnet_code_quality.CA1040.api_surface = public, internal</c></description></item>
             <item><description><c>dotnet_code_quality.Naming.api_surface = public</c></description></item>
             </list>
             </description></item>
             </list>
            
             <para>See <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> for allowed symbol visibility value combinations.</para>
             </summary>
        </member>
        <member name="T:Analyzer.Utilities.AggregateCategorizedAnalyzerConfigOptions">
             <summary>
             Aggregate analyzer configuration options:
            
             <list type="number">
             <item><description>Per syntax tree options from <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider"/>.</description></item>
             <item><description>Options from an <strong>.editorconfig</strong> file passed in as an additional file (back compat).</description></item>
             </list>
            
             <inheritdoc cref="T:Analyzer.Utilities.ICategorizedAnalyzerConfigOptions"/>
             </summary>
        </member>
        <member name="F:Analyzer.Utilities.SymbolNamesWithValueOption`1._wildcardNamesBySymbolKind">
            <summary>
            Dictionary holding per symbol kind the wildcard entry with its suffix.
            The implementation only supports the following SymbolKind: Namespace, Type, Event, Field, Method, Property and ErrorType (as a way to hold the non-fully qualified types).
            </summary>
            <example>
            ErrorType ->
                Symbol* -> "some value"
            Namespace ->
                Analyzer.Utilities -> ""
            Type ->
                Analyzer.Utilities.SymbolNamesWithValueOption -> ""
            Event ->
                Analyzer.Utilities.SymbolNamesWithValueOption.MyEvent -> ""
            Field ->
                Analyzer.Utilities.SymbolNamesWithValueOption.myField -> ""
            Method ->
                Analyzer.Utilities.SymbolNamesWithValueOption.MyMethod() -> ""
            Property ->
                Analyzer.Utilities.SymbolNamesWithValueOption.MyProperty -> ""
            </example>
        </member>
        <member name="F:Analyzer.Utilities.SymbolNamesWithValueOption`1._wildcardMatchResult">
            <summary>
            Cache for the wildcard matching algorithm. The current implementation can be slow so we want to make sure that once a match is performed we save its result.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SymbolNamesWithValueOption`1.TryGetValue(Microsoft.CodeAnalysis.ISymbol,`0@)">
            <summary>
            Gets the value associated with the specified symbol in the option specification.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.SymbolNamesWithValueOption`1.NameParts">
            <summary>
            Represents the two parts of a symbol name option when the symbol name is tighted to some specific value.
            This allows to link a value to a symbol while following the symbol's documentation ID format.
            </summary>
            <example>
            On the rule CA1710, we allow user specific suffix to be registered for symbol names using the following format:
            MyClass->Suffix or T:MyNamespace.MyClass->Suffix or N:MyNamespace->Suffix.
            </example>
        </member>
        <member name="T:Analyzer.Utilities.SymbolModifiers">
            <summary>
            Describes a group of modifiers for symbol declaration.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Unit">
            <summary>
            Represents a type with a single value. This type is often used to denote the successful completion of a void-returning method (C#) or a Sub procedure (Visual Basic).
            </summary>
            <remarks>
            This class is a duplicate from "https://github.com/dotnet/reactive/blob/main/Rx.NET/Source/src/System.Reactive/Unit.cs
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Unit.Equals(Analyzer.Utilities.Unit)">
            <summary>
            Determines whether the specified <see cref="T:Analyzer.Utilities.Unit"/> value is equal to the current <see cref="T:Analyzer.Utilities.Unit"/>. Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.
            </summary>
            <param name="other">An object to compare to the current <see cref="T:Analyzer.Utilities.Unit"/> value.</param>
            <returns>Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current <see cref="T:Analyzer.Utilities.Unit"/>.
            </summary>
            <param name="obj">The System.Object to compare with the current <see cref="T:Analyzer.Utilities.Unit"/>.</param>
            <returns><c>true</c> if the specified System.Object is a <see cref="T:Analyzer.Utilities.Unit"/> value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Analyzer.Utilities.Unit"/> value.
            </summary>
            <returns>A hash code for the current <see cref="T:Analyzer.Utilities.Unit"/> value.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.ToString">
            <summary>
            Returns a string representation of the current <see cref="T:Analyzer.Utilities.Unit"/> value.
            </summary>
            <returns>String representation of the current <see cref="T:Analyzer.Utilities.Unit"/> value.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.op_Equality(Analyzer.Utilities.Unit,Analyzer.Utilities.Unit)">
            <summary>
            Determines whether the two specified <see cref="T:Analyzer.Utilities.Unit"/> values are equal. Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.
            </summary>
            <param name="first">The first <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <param name="second">The second <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <returns>Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.op_Inequality(Analyzer.Utilities.Unit,Analyzer.Utilities.Unit)">
            <summary>
            Determines whether the two specified <see cref="T:Analyzer.Utilities.Unit"/> values are not equal. Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>false</c>.
            </summary>
            <param name="first">The first <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <param name="second">The second <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <returns>Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>false</c>.</returns>
        </member>
        <member name="P:Analyzer.Utilities.Unit.Default">
            <summary>
            Gets the single <see cref="T:Analyzer.Utilities.Unit"/> value.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.None">
            <summary>
            Represents default value indicating no usage.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.Read">
            <summary>
            Represents a value read.
            For example, reading the value of a local/field/parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.Write">
            <summary>
            Represents a value write.
            For example, assigning a value to a local/field/parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.Reference">
            <summary>
            Represents a reference being taken for the symbol.
            For example, passing an argument to an "in", "ref" or "out" parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.Name">
            <summary>
            Represents a name-only reference that neither reads nor writes the underlying value.
            For example, 'nameof(x)' or reference to a symbol 'x' in a documentation comment
            does not read or write the underlying value stored in 'x'.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.ReadWrite">
            <summary>
            Represents a value read and/or write.
            For example, an increment or compound assignment operation.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.ReadableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "in" or "ref readonly" parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.WritableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "out" parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.ReadableWritableReference">
            <summary>
            Represents a value read or write.
            For example, passing an argument to a "ref" parameter.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.EditorConfigOptionNames">
            <summary>
            Option names to configure analyzer execution through an .editorconfig file.
            </summary>
            <summary>
            Option names to configure analyzer execution through an .editorconfig file.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ApiSurface">
            <summary>
            Option to configure analyzed API surface.
            Allowed option values: One or more fields of flags enum <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.RequiredModifiers">
            <summary>
            Option to configure required modifiers for analyzed APIs.
            Allowed option values: One or more fields of flags enum <see cref="T:Analyzer.Utilities.SymbolModifiers"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeAsyncVoidMethods">
            <summary>
            Boolean option to exclude analysis of async void methods.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.EnablePlatformAnalyzerOnPreNet5Target">
            <summary>
            Boolean option to enable platform compatibility analyzer for TFMs with lower version than net5.0 (https://learn.microsoft.com/visualstudio/code-quality/ca1416).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.OutputKind">
            <summary>
            Option to configure analyzed output kinds, i.e. <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind"/> of the compilation.
            Allowed option values: One or more fields of <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeSingleLetterTypeParameters">
            <summary>
            Boolean option to configure if single letter type parameter names are not flagged for CA1715 (https://learn.microsoft.com/visualstudio/code-quality/ca1715).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.SufficientIterationCountForWeakKDFAlgorithm">
            <summary>
            Integral option to configure sufficient IterationCount when using weak KDF algorithm.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeExtensionMethodThisParameter">
            <summary>
            Boolean option to exclude analysis of 'this' parameter for extension methods.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.NullCheckValidationMethods">
            <summary>
            String option to configure names of null check validation methods (separated by '|') that validate arguments passed to the method are non-null for CA1062 (https://learn.microsoft.com/visualstudio/code-quality/ca1062).
            Allowed method name formats:
              1. Method name only (includes all methods with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "M:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalStringFormattingMethods">
            <summary>
            String option to configure names of additional string formatting methods (separated by '|') for CA2241 (https://learn.microsoft.com/visualstudio/code-quality/ca2241).
            Allowed method name formats:
              1. Method name only (includes all methods with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "M:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.TryDetermineAdditionalStringFormattingMethodsAutomatically">
            <summary>
            Boolean option to enable heuristically detecting of additional string formatting methods for CA2241 (https://learn.microsoft.com/visualstudio/code-quality/ca2241).
            A method is considered a string formatting method if it has a '<see cref="T:System.String"/> <c>format</c>' parameter followed by a <see langword="params"/> <see cref="T:System.Object"/>[]' parameter.
            The default value of this is <c>false</c>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludedSymbolNames">
            <summary>
            String option to configure names of symbols (separated by '|') that are excluded for analysis.
            Configurable rules: CA1303 (https://learn.microsoft.com/visualstudio/code-quality/ca1303).
            Allowed method name formats:
              1. Symbol name only (includes all symbols with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format.
                 Note that each symbol name requires a symbol kind prefix, such as "M:" prefix for methods, "T:" prefix for types, "N:" prefix for namespaces, etc.
              3. ".ctor" for constructors and ".cctor" for static constructors
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludedTypeNamesWithDerivedTypes">
            <summary>
            String option to configure names of types (separated by '|'), so that the type and all its derived types are excluded for analysis.
            Configurable rules: CA1303 (https://learn.microsoft.com/visualstudio/code-quality/ca1303).
            Allowed method name formats:
              1. Type name only (includes all types with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "T:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.DisallowedSymbolNames">
            <summary>
            String option to configure names of symbols (separated by '|') that are disallowed in analysis.
            Configurable rules: CA1031 (https://learn.microsoft.com/visualstudio/code-quality/ca1031).
            Allowed method name formats:
              1. Symbol name only (includes all symbols with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format.
                 Note that each symbol name requires a symbol kind prefix, such as "M:" prefix for methods, "T:" prefix for types, "N:" prefix for namespaces, etc.
              3. ".ctor" for constructors and ".cctor" for static constructors
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.UnsafeDllImportSearchPathBits">
            <summary>
            Enumeration option to configure unsafe DllImportSearchPath bits when using DefaultDllImportSearchPaths attribute.
            Do not use the OR operator to represent the bitwise combination of its member values, use the integral value directly.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeAspnetCoreMvcControllerBase">
            <summary>
            Boolean option to configure whether to exclude aspnet core mvc ControllerBase when considering CSRF.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.EnumValuesPrefixTrigger">
            <summary>
            String option to configure how many enum values should be prefixed by the enum type name to trigger the rule.
            Configurable rules: CA1712 (https://learn.microsoft.com/visualstudio/code-quality/ca1712)
            Allowed method name formats:
              1. Any of the enum values starts with the enum type name
              2. All of the enum values starts with the enum type name
              3. Default FxCop heuristic (75% of enum values)
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalRequiredSuffixes">
            <summary>
            String option to configure names of types (separated by '|'), with their suffixes (separated by '->').
            Configurable rules: CA1710 (https://learn.microsoft.com/visualstudio/code-quality/ca1710).
            Allowed type name formats:
              1. Type name only (includes all types with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "T:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeIndirectBaseTypes">
            <summary>
            Boolean option to prevent analyzing indirect base types (walking more than one level up) when suggesting suffixes.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalRequiredGenericInterfaces">
            <summary>
            String option to configure names of interfaces (separated by '|'), with their required generic interfaces (separated by '->').
            Configurable rules: CA1010 (https://learn.microsoft.com/visualstudio/code-quality/ca1010)
            Allowed interface formats:
              1. Interface name only(includes all interfaces with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format with an optional "T:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalInheritanceExcludedSymbolNames">
            <summary>
            Names of types or namespaces (separated by '|'), such that the type or type's namespace doesn't count in the inheritance hierarchy tree.
            Configurable rules: CA1501 (https://learn.microsoft.com/visualstudio/code-quality/ca1501)
            Allowed name formats:
              1. Type or namespace name (includes all types with the name, regardless of the containing type or namespace and all types whose namespace contains the name)
              2. Type or namespace name ending with a wildcard symbol (includes all types whose name starts with the given name, regardless of the containing type or namespace
                 and all types whose namespace contains the name)
              3. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format with an optional "T:" prefix for types or "N:" prefix for namespaces. (includes all types with the exact type match or the exact containing namespace match)
              4. Fully qualified type or namespace name with an optional "T:" prefix for type or "N:" prefix for namespace and ending with the wildcard symbol (includes all types whose fully qualified name starts with the given suffix)
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AnalyzedSymbolKinds">
            <summary>
            Option to configure analyzed symbol kinds, i.e. <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>.
            Allowed option values: One or more fields of <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.UseNamingHeuristic">
            <summary>
            Boolean option to configure if the naming heuristic should be used for CA1303 (https://learn.microsoft.com/visualstudio/code-quality/ca1303).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalUseResultsMethods">
            <summary>
            String option to configure names of additional methods (separated by '|') for CA1806 (https://learn.microsoft.com/visualstudio/code-quality/ca1806).
            Allowed method name formats:
              1. Method name only (includes all methods with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "M:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AllowedSuffixes">
            <summary>
            String option to configure allowed suffixed (separated by '|').
            Configurable rule: CA1711 (https://learn.microsoft.com/visualstudio/code-quality/ca1711).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeStructs">
            <summary>
            Boolean option to configure whether to exclude structs when considering public fields.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeOrDefaultMethods">
            <summary>
            Boolean option to configure whether to exclude 'FirstOrDefault' and 'LastOrDefault' methods for
            CA1826 (Do not use Enumerable methods on indexable collections. Instead use the collection directly).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.EnumerationMethods">
            <summary>
            String option to configure names of method symbols (separated by '|') that marks all of the parameters with IEnumerable type
            would be enumerated.
            Configurable rule: CA1851 (https://learn.microsoft.com/visualstudio/code-quality/ca1851).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.LinqChainMethods">
            <summary>
            String option to configure names of method symbols (separated by '|') that accepting parameter with IEnumerable type and return a new IEnumerable type, like 'Select' and 'Where'.
            Configurable rule: CA1851 (https://learn.microsoft.com/visualstudio/code-quality/ca1851).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AssumeMethodEnumeratesParameters">
            <summary>
            Boolean option to configure the assumption that IEnumerable type parameters would be enumerated by method invocation or not.
            It does not affect linq_chain_methods.
            Configurable rule: CA1851 (https://learn.microsoft.com/visualstudio/code-quality/ca1851).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalEnumNoneNames">
            <summary>
            String option to configure names of additional "None" enum case (separated by '|') for CA1008.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.InterproceduralAnalysisKind">
            <summary>
            Option to configure interprocedural dataflow analysis kind, i.e. <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind"/>.
            Allowed option values: Fields from <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.MaxInterproceduralMethodCallChain">
            <summary>
            Integral option to configure maximum method call chain for interprocedural dataflow analysis.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.MaxInterproceduralLambdaOrLocalFunctionCallChain">
            <summary>
            Integral option to configure maximum lambda or local function call chain for interprocedural dataflow analysis.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.DisposeAnalysisKind">
            <summary>
            String option to configure dispose analysis kind, primarily for CA2000 (DisposeObjectsBeforeLosingScope).
            Allowed option values: Fields from DisposeAnalysisKind enum.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.DisposeOwnershipTransferAtConstructor">
            <summary>
            Boolean option to configure if passing a disposable object as a constructor argument should be considered
            as a dispose ownership transfer, primarily for CA2000 (DisposeObjectsBeforeLosingScope).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.DisposeOwnershipTransferAtMethodCall">
            <summary>
            Boolean option to configure if passing a disposable object as an argument to a method invocation should be considered
            as a dispose ownership transfer to the caller, primarily for CA2000 (DisposeObjectsBeforeLosingScope)
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.CopyAnalysis">
            <summary>
            Option to configure whether copy analysis should be executed during dataflow analysis.
            Copy analysis tracks value and reference copies. For example,
            <code>
                void M(string str1, string str2)
                {
                    if (str1 != null)
                    {
                        if (str1 == str2)
                        {
                            if (str2 != null) // This is redundant as 'str1' and 'str2' are value copies on this code path. This requires copy analysis.
                            {
                            }
                        }
                    }
                }
            </code>
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.PointsToAnalysisKind">
            <summary>
            Option to configure points to analysis kind, i.e. <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisKind"/>.
            Allowed option values: Fields from <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisKind"/>.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.SymbolVisibilityGroup">
            <summary>
            Describes a group of effective <see cref="T:Analyzer.Utilities.Extensions.SymbolVisibility"/> for symbols.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.AnalyzerOptionsExtensions.MatchesConfiguredVisibility(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,Analyzer.Utilities.SymbolVisibilityGroup)">
            <summary>
            Returns true if the given source symbol has required visibility based on options:
              1. If user has explicitly configured candidate <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> in editor config options and
                 given symbol's visibility is one of the candidate visibilities.
              2. Otherwise, if user has not configured visibility, and given symbol's visibility
                 matches the given default symbol visibility.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.AnalyzerOptionsExtensions.MatchesConfiguredVisibility(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,Analyzer.Utilities.SymbolVisibilityGroup)">
            <summary>
            Returns true if the given symbol has required visibility based on options in context of the given containing symbol:
              1. If user has explicitly configured candidate <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> in editor config options and
                 given symbol's visibility is one of the candidate visibilities.
              2. Otherwise, if user has not configured visibility, and given symbol's visibility
                 matches the given default symbol visibility.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.AnalyzerOptionsExtensions.MatchesConfiguredModifiers(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,Analyzer.Utilities.SymbolModifiers)">
            <summary>
            Returns true if the given symbol has required symbol modifiers based on options:
              1. If user has explicitly configured candidate <see cref="T:Analyzer.Utilities.SymbolModifiers"/> in editor config options and
                 given symbol has all the required modifiers.
              2. Otherwise, if user has not configured modifiers.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.RoslynString.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Analyzer.Utilities.RoslynString.IsNullOrWhiteSpace(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
        </member>
        <member name="T:Analyzer.Utilities.SmallDictionary`2">
             <summary>
             Copied from https://github.com/dotnet/roslyn/blob/main/src/Compilers/Core/Portable/Collections/SmallDictionary.cs
             Dictionary designed to hold small number of items.
             Compared to the regular Dictionary, average overhead per-item is roughly the same, but
             unlike regular dictionary, this one is based on an AVL tree and as such does not require
             rehashing when items are added.
             It does require rebalancing, but that is allocation-free.
            
             Major caveats:
              1) There is no Remove method. (can be added, but we do not seem to use Remove that much)
              2) foreach [keys|values|pairs] may allocate a small array.
              3) Performance is no longer O(1). At a certain count it becomes slower than regular Dictionary.
                 In comparison to regular Dictionary on my machine:
                    On trivial number of elements (5 or so) it is more than 2x faster.
                    The break even count is about 120 elements for read and 55 for write operations (with unknown initial size).
                    At UShort.MaxValue elements, this dictionary is 6x slower to read and 4x slower to write
            
             Generally, this dictionary is a win if number of elements is small, not known beforehand or both.
            
             If the size of the dictionary is known at creation and it is likely to contain more than 10 elements,
             then regular Dictionary is a better choice.
             </summary>
        </member>
        <member name="T:Analyzer.Utilities.SymbolDisplayStringCache">
            <summary>
            Cache ISymbol.ToDisplayName() results, to avoid performance concerns.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.SymbolDisplayStringCache.s_byCompilationCache">
            <summary>
            Caches by compilation.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.SymbolDisplayStringCache.NullSymbolDisplayFormat">
            <summary>
            ConcurrentDictionary key for a null SymbolDisplayFormat.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.SymbolDisplayStringCache.SymbolToDisplayNames">
            <summary>
            Mapping of a symbol to its ToDisplayString().
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SymbolDisplayStringCache.#ctor(Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Privately constructs.
            </summary>
            <param name="format">SymbolDisplayFormat to use, or null for the default.</param>
        </member>
        <member name="M:Analyzer.Utilities.SymbolDisplayStringCache.GetOrCreate(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Gets the symbol display string cache for the compilation.
            </summary>
            <param name="compilation">Compilation that this cache is for.</param>
            <param name="format">A singleton SymbolDisplayFormat to use, or null for the default.</param>
            <returns>A SymbolDisplayStringCache.</returns>
        </member>
        <member name="M:Analyzer.Utilities.SymbolDisplayStringCache.GetDisplayString(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the symbol's display string.
            </summary>
            <param name="symbol">Symbol to get the display string.</param>
            <returns>The symbol's display string.</returns>
        </member>
        <member name="T:Analyzer.Utilities.SymbolByDisplayStringComparer">
            <summary>
            <see cref="T:System.Collections.Generic.IComparer`1"/> for <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/>s sorted by display strings.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SymbolByDisplayStringComparer.#ctor(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Constructs.
            </summary>
            <param name="compilation">The compilation containing the types to be compared.</param>
        </member>
        <member name="M:Analyzer.Utilities.SymbolByDisplayStringComparer.#ctor(Analyzer.Utilities.SymbolDisplayStringCache)">
            <summary>
            Constructs.
            </summary>
            <param name="symbolDisplayStringCache">The cache display strings to use.</param>
        </member>
        <member name="P:Analyzer.Utilities.SymbolByDisplayStringComparer.SymbolDisplayStringCache">
            <summary>
            Cache of symbol display strings.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SymbolByDisplayStringComparer.Compare(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Compares two type symbols by their display strings.
            </summary>
            <param name="x">First type symbol to compare.</param>
            <param name="y">Second type symbol to compare.</param>
            <returns>Less than 0 if <paramref name="x"/> is before <paramref name="y"/>, 0 if equal, greater than 0 if
            <paramref name="x"/> is after <paramref name="y"/>.</returns>
        </member>
        <member name="T:Analyzer.Utilities.UnusedValue">
            <summary>
            A placeholder value type for <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> used as a set.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.WellKnownTypeProvider">
            <summary>
            Provides and caches well known types in a compilation.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WellKnownTypeProvider._referencedAssemblies">
            <summary>
            All the referenced assembly symbols.
            </summary>
            <remarks>
            Seems to be less memory intensive than:
            foreach (Compilation.Assembly.Modules)
                foreach (Module.ReferencedAssemblySymbols)
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.WellKnownTypeProvider._fullNameToTypeMap">
            <summary>
            Mapping of full name to <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WellKnownTypeProvider._fullTypeNameToNamespaceNames">
             <summary>
             Static cache of full type names (with namespaces) to namespace name parts,
             so we can query <see cref="P:Microsoft.CodeAnalysis.IAssemblySymbol.NamespaceNames"/>.
             </summary>
             <remarks>
             Example: "System.Collections.Generic.List`1" => [ "System", "Collections", "Generic" ]
            
             https://github.com/dotnet/roslyn/blob/9e786147b8cb884af454db081bb747a5bd36a086/src/Compilers/CSharp/Portable/Symbols/AssemblySymbol.cs#L455
             suggests the TypeNames collection can be checked to avoid expensive operations. But realizing TypeNames seems to be
             as memory intensive as unnecessary calls GetTypeByMetadataName() in some cases. So we'll go with namespace names.
             </remarks>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.TryGetOrCreateTypeByMetadataName(System.String,Microsoft.CodeAnalysis.INamedTypeSymbol@)">
            <summary>
            Attempts to get the type by the full type name.
            </summary>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <param name="namedTypeSymbol">Named type symbol, if any.</param>
            <returns>True if found in the compilation, false otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.GetOrCreateTypeByMetadataName(System.String)">
            <summary>
            Gets a type by its full type name.
            </summary>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> if found, null otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.IsTaskOfType(Microsoft.CodeAnalysis.ITypeSymbol,System.Func{Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean})">
            <summary>
            Determines if <paramref name="typeSymbol"/> is a <see cref="T:System.Threading.Tasks.Task`1"/> with its type
            argument satisfying <paramref name="typeArgumentPredicate"/>.
            </summary>
            <param name="typeSymbol">Type potentially representing a <see cref="T:System.Threading.Tasks.Task`1"/>.</param>
            <param name="typeArgumentPredicate">Predicate to check the <paramref name="typeSymbol"/>'s type argument.</param>
            <returns>True if <paramref name="typeSymbol"/> is a <see cref="T:System.Threading.Tasks.Task`1"/> with its
            type argument satisfying <paramref name="typeArgumentPredicate"/>, false otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of an identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="T:Analyzer.Utilities.BoundedCache`2">
            <summary>
            Provides bounded cache for analyzers.
            Acts as a good alternative to <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/>
            when the cached value has a cyclic reference to the key preventing early garbage collection of entries.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.WordParser">
            <summary>
                Provides <see langword="static"/> methods for parsing words from text.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.#ctor(System.String,Analyzer.Utilities.WordParserOptions)">
            <summary>
                Initializes a new instance of the <see cref="T:Analyzer.Utilities.WordParser"/> class with the specified text and options.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.#ctor(System.String,Analyzer.Utilities.WordParserOptions,System.Char)">
            <summary>
                Initializes a new instance of the <see cref="T:Analyzer.Utilities.WordParser"/> class with the specified text, options and prefix.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="prefix">
                A <see cref="T:System.Char"/> representing an optional prefix of <paramref name="text"/>, that if present,
                will be returned as a separate token.
            </param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)">
            <summary>
                Returns the words contained in the specified text, delimiting based on the specified options.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <returns>
                A <see cref="T:System.Collections.ObjectModel.Collection`1"/> of strings containing the words contained in <paramref name="text"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions,System.Char)">
            <summary>
                Returns the words contained in the specified text, delimiting based on the specified options.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="prefix">
                A <see cref="T:System.Char"/> representing an optional prefix of <paramref name="text"/>, that if present,
                will be returned as a separate token.
            </param>
            <returns>
                A <see cref="T:System.Collections.ObjectModel.Collection`1"/> of strings containing the words contained in <paramref name="text"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.ContainsWord(System.String,Analyzer.Utilities.WordParserOptions,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
                Returns a value indicating whether at least one of the specified words occurs, using a case-insensitive ordinal comparison, within the specified text.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to check.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="words">
                A <see cref="T:System.String"/> array containing the words to seek.
            </param>
            <returns>
                <see langword="true"/> if at least one of the elements within <paramref name="words"/> occurs within <paramref name="text"/>, otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
                <para>
                 -or-
                </para>
                <paramref name="words"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.ContainsWord(System.String,Analyzer.Utilities.WordParserOptions,System.Char,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
                Returns a value indicating whether at least one of the specified words occurs, using a case-insensitive ordinal comparison, within the specified text.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to check.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="prefix">
                A <see cref="T:System.Char"/> representing an optional prefix of <paramref name="text"/>, that if present,
                will be returned as a separate token.
            </param>
            <param name="words">
                A <see cref="T:System.String"/> array containing the words to seek.
            </param>
            <returns>
                <see langword="true"/> if at least one of the elements within <paramref name="words"/> occurs within <paramref name="text"/>, otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
                <para>
                 -or-
                </para>
                <paramref name="words"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.NextWord">
            <summary>
                Returns the next word in the text.
            </summary>
            <returns>
                A <see cref="T:System.String"/> containing the next word or <see langword="null"/> if there are no more words.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.PeekWord">
            <summary>
                Returns the next word in the text without consuming it.
            </summary>
            <returns>
                A <see cref="T:System.String"/> containing the next word or <see langword="null"/> if there are no more words.
            </returns>
        </member>
        <member name="T:Analyzer.Utilities.WordParserOptions">
            <summary>
              Defines the word parsing and delimiting options for use with <see cref="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WordParserOptions.None">
            <summary>
              Indicates the default options for word parsing.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WordParserOptions.IgnoreMnemonicsIndicators">
            <summary>
              Indicates that <see cref="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)"/> should ignore the mnemonic indicator characters (&amp;) embedded within words.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WordParserOptions.SplitCompoundWords">
            <summary>
              Indicates that <see cref="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)"/> should split compound words.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.DisposeAnalysisHelper">
            <summary>
            Helper for DisposeAnalysis.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.DisposeAnalysisHelper.IsDisposableCreationOrDisposeOwnershipTransfer(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns true if the given <paramref name="location"/> was created for an allocation in the <paramref name="containingMethod"/>
            or represents a location created for a constructor parameter whose type indicates dispose ownership transfer.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.DisposeAnalysisKind">
            <summary>
            Describes a group of effective <see cref="T:Analyzer.Utilities.Extensions.SymbolVisibility"/> for symbols.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeAnalysisKind.AllPaths">
            <summary>
            Track and report missing dispose violations on all paths (non-exception and exception paths).
            Additionally, also flag use of non-recommended dispose patterns that may cause
            potential dispose leaks.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeAnalysisKind.AllPathsOnlyNotDisposed">
            <summary>
            Track and report missing dispose violations on all paths (non-exception and exception paths).
            Do not flag use of non-recommended dispose patterns that may cause
            potential dispose leaks.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeAnalysisKind.NonExceptionPaths">
            <summary>
            Track and report missing dispose violations only on non-exception program paths.
            Additionally, also flag use of non-recommended dispose patterns that may cause
            potential dispose leaks.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeAnalysisKind.NonExceptionPathsOnlyNotDisposed">
            <summary>
            Track and report missing dispose violations only on non-exception program paths.
            Do not flag use of non-recommended dispose patterns that may cause
            potential dispose leaks.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.SingleThreadedConcurrentDictionary`2">
            <summary>
            Like ConcurrentDictionary, but single threaded valueFactory execution in GetOrAdd.
            </summary>
            <remarks>Useful for long running valueFactory functions, like say performing 
            dataflow analysis.  This way DFA is invoked only once per key, even if multiple
            threads simultaneously request the same key.</remarks>
        </member>
        <member name="T:Analyzer.Utilities.SingleThreadedConcurrentDictionary`2.Entry">
            <summary>
            An Entry itself serves a lock object, and contains the real value.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.SingleThreadedConcurrentDictionary`2.BackingDictionary">
            <summary>
            Holds entries, which contain the actual values.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SingleThreadedConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds a key/value pair using the specified function if the key does not already exist.  Returns the new value, or the existing value if the key exists.
            </summary>
            <param name="key">Key to add.</param>
            <param name="valueFactory">Function to be invoked to generate the key, if necessary.</param>
            <returns>Value of the key, which will either be the existing value, or new value if the key was not in the dictionary.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData">
            <summary>
            Code analysis metrics data.
            See https://learn.microsoft.com/visualstudio/code-quality/code-metrics-values for more details
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.Symbol">
            <summary>
            Symbol corresponding to the metric data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.MaintainabilityIndex">
            <summary>
            Indicates an index value between 0 and 100 that represents the relative ease of maintaining the code.
            A high value means better maintainability.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.CoupledNamedTypes">
            <summary>
            Indicates the coupling to unique named types through parameters, local variables, return types, method calls,
            generic or template instantiations, base classes, interface implementations, fields defined on external types, and attribute decoration.
            Good software design dictates that types and methods should have high cohesion and low coupling.
            High coupling indicates a design that is difficult to reuse and maintain because of its many interdependencies on other types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.SourceLines">
            <summary>
            Indicates the exact number of lines in source code file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ExecutableLines">
            <summary>
            Indicates the approximate number of executable statements/lines in code.
            The count is based on the executable <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s in code and is therefore not the exact number of lines in the source code file.
            A high count might indicate that a type or method is trying to do too much work and should be split up.
            It might also indicate that the type or method might be hard to maintain.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.CyclomaticComplexity">
            <summary>
            Measures the structural complexity of the code.
            It is created by calculating the number of different code paths in the flow of the program.
            A program that has complex control flow requires more tests to achieve good code coverage and is less maintainable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.DepthOfInheritance">
            <summary>
            Indicates the number of different classes that inherit from one another, all the way back to the base class.
            Depth of Inheritance is similar to class coupling in that a change in a base class can affect any of its inherited classes.
            The higher this number, the deeper the inheritance and the higher the potential for base class modifications to result in a breaking change.
            For Depth of Inheritance, a low value is good and a high value is bad.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.Children">
            <summary>
            Array of code metrics data for symbolic children of <see cref="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.Symbol"/>, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ToString">
            <summary>
            Computes string representation of metrics data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.CodeMetrics.CodeMetricsAnalysisContext)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="symbol"/> from the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.CodeMetrics.CodeMetricsAnalysisContext)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="symbol"/> from the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics">
            <summary>
            Calculates computational complexity metrics based on the number
            of operators and operands found in the code.
            </summary>
            <remarks>This metric is based off of the Halstead metric.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.DistinctOperators">
            <summary>The number of unique operators found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.DistinctOperands">
            <summary>The number of unique operands found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.TotalOperators">
            <summary>The total number of operator usages found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.TotalOperands">
            <summary>The total number of operand usages found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.ExecutableLines">
            <summary>
            Count of executable lines of code, i.e. basically IOperations parented by IBlockOperation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.EffectiveLinesOfCode">
            <summary>
            Count of effective lines of code for computation of maintainability index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RulesetToEditorconfig.Converter.GenerateEditorconfig(System.String,System.String)">
            <summary>
            Converts a ruleset file at the given <paramref name="rulesetFilePath"/>, including all its ruleset includes,
            into an .editorconfig file at the given <paramref name="editorconfigFilePath"/>
            </summary>
            <exception cref="T:System.IO.IOException">Exception while performing any I/O on given file paths.</exception>
            <exception cref="T:Microsoft.CodeAnalysis.InvalidRuleSetException">Exception for invalid ruleset files.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RulesetToEditorconfig.Converter.GetEditorconfig(System.String)">
            <summary>
            Gets an .editorconfig representation for a ruleset file at the given <paramref name="rulesetFilePath"/>,
            including all its ruleset includes.
            </summary>
            <returns>Text for equivalent .editorconfig</returns>
            <exception cref="T:System.IO.IOException">Exception while performing any I/O on given file paths.</exception>
            <exception cref="T:Microsoft.CodeAnalysis.InvalidRuleSetException">Exception for invalid ruleset file.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis">
            <summary>
            Dataflow analysis to track <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances that share the same value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis.SetCopyAbstractValuePredicateKind">
            <summary>
            Predicate kind for <see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis.CopyDataFlowOperationVisitor.SetAbstractValue(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysisData,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue,System.Func{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue},System.Nullable{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis.SetCopyAbstractValuePredicateKind},System.Boolean)"/>
            to indicte if the copy equality check for the SetAbstractValue call is a reference compare or a value compare operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis.CopyAbstractValueDomain">
            <summary>
            Abstract value domain for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis"/> to merge and compare <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue"/> values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis.CopyDataFlowOperationVisitor">
            <summary>
            Operation visitor to flow the copy values across a given statement in a basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis.CoreCopyAnalysisDataDomain">
            <summary>
            An abstract analysis domain implementation for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData`2"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.AddressSharedEntitiesProvider`4">
            <summary>
            Generates and stores the default <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue"/> for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances generated for member and element reference operations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.AddressSharedEntitiesProvider`4._addressSharedEntitiesBuilder">
            <summary>
            Map builder from entity to set of entities that share the same instance location.
            Primarily used for ref arguments for context sensitive interprocedural analysis
            to ensure that PointsTo value updates to any of the mapped entities is reflected in the others in the set.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue">
            <summary>
            Abstract copy value shared by a set of one of more <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKind">
            <summary>
            Kind for the <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKind.NotApplicable">
            <summary>
            Not applicable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKind.KnownReferenceCopy">
            <summary>
            Copy of a reference shared by one or more <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKind.KnownValueCopy">
            <summary>
            Copy of a value shared by one or more <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKind.Unknown">
            <summary>
            Copy may or may not be shared by other <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKind.Invalid">
            <summary>
            Invalid state for an unreachable path from predicate analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysisData">
            <summary>
            Aggregated copy analysis data tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis"/>.
            Contains the <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData`2"/> for entity copy values and
            the predicated copy values based on true/false runtime values of predicated entities.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysisData.SetAbstactValueForEntities(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity)">
            <summary>
            Updates the copy values for all entities that are part of the given <paramref name="copyValue"/> set,
            i.e. <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue.AnalysisEntities"/>.
            We do not support the <see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysisData.SetAbstractValue(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue)"/> overload
            that updates copy value for each individual entity.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyBlockAnalysisResult">
            <summary>
            Result from execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis"/> on a basic block.
            It store copy values for each <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> at the start and end of the basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysisContext">
            <summary>
            Analysis context for execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis"/> on a control flow graph.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.IAbstractAnalysisValue">
            <summary>
            Abstract analysis value for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysis"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.IAbstractAnalysisValue.GetNegatedValue">
            <summary>
            Return negated value if the analysis value is a predicated value.
            Otherwise, return the current instance itself.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.IAbstractAnalysisValue.ToString">
            <summary>
            String representation of the abstract value.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysisValueSetKind.Unset">
            <summary>
            Unset value set.
            This is needed along with Empty to ensure the following merge results:
            Unset + Known = Known
            Empty + Known = Empty
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysisValueSetKind.Known">
            <summary>
            One or more known set of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.IAbstractAnalysisValue"/>s.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysisValueSetKind.Empty">
            <summary>
            No <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.IAbstractAnalysisValue"/>s.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysisValueSetKind.Unknown">
            <summary>
            Unknown set of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.IAbstractAnalysisValue"/>s.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysis">
            <summary>
            Dataflow analysis to track set of global <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.IAbstractAnalysisValue"/>s enabled on each control flow path at each <see cref="T:Microsoft.CodeAnalysis.IOperation"/> in the <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysis.TryGetOrComputeResult(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph,Microsoft.CodeAnalysis.ISymbol,System.Func{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysisContext,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateValueSetFlowOperationVisitor},Analyzer.Utilities.WellKnownTypeProvider,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysisResult{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentBlockAnalysisResult,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue}@,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisPredicate,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.INamedTypeSymbol},System.Func{Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue})">
             <summary>
             Performs global flow state analysis and returns the analysis result.
             </summary>
             <param name="cfg">Control flow graph to analyze.</param>
             <param name="owningSymbol">Owning symbol for the analyzed <paramref name="cfg"/>.</param>
             <param name="createOperationVisitor">Delegate to create a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateValueSetFlowOperationVisitor"/> that performs the core analysis.</param>
             <param name="wellKnownTypeProvider">Well-known type provider for the compilation.</param>
             <param name="analyzerOptions">Analyzer options for analysis</param>
             <param name="rule"><see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for fetching any rule specific analyzer option values from <paramref name="analyzerOptions"/>.</param>
             <param name="performValueContentAnalysis">Flag to indicate if <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis"/> should be performed.</param>
             <param name="pessimisticAnalysis">
             This boolean field determines if we should perform an optimistic OR a pessimistic analysis.
             For example, invoking a lambda method for which we do not know the target method being invoked can change/invalidate the current global flow state.
             An optimistic points to analysis assumes that the global flow state doesn't change for such scenarios.
             A pessimistic points to analysis resets the global flow state to an unknown state for such scenarios.
             </param>
             <param name="valueContentAnalysisResult">Optional value content analysis result, if <paramref name="performValueContentAnalysis"/> is true</param>
             <param name="interproceduralAnalysisKind"><see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind"/> for the analysis.</param>
             <param name="interproceduralAnalysisPredicate">Optional predicate for interprocedural analysis.</param>
             <param name="additionalSupportedValueTypes">Additional value types for which the caller wants to track stored values during value content analysis.</param>
             <param name="getValueContentValueForAdditionalSupportedValueTypeOperation">
             Optional delegate to compute values for <paramref name="additionalSupportedValueTypes"/>.
             Must be non-null if <paramref name="additionalSupportedValueTypes"/> is non-empty.
             </param>
            
             <returns>Global flow state analysis result, or null if analysis did not succeed.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateValueSetFlowOperationVisitor">
            <summary>
            Operation visitor to flow the GlobalFlowState values across a given statement in a basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysisContext">
            <summary>
            Analysis context for execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysis"/> on a control flow graph.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateBlockAnalysisResult">
            <summary>
            Result from execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysis"/> on a basic block.
            It store GlobalFlowState value at the start and end of the basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateDataFlowOperationVisitor`3">
            <summary>
            Operation visitor to flow the GlobalFlowState values across a given statement in a basic block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisKind.None">
            <summary>
            Analysis is disabled.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisKind.PartialWithoutTrackingFieldsAndProperties">
            <summary>
            Partial analysis that tracks <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue"/> for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>
            except fields and properties.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisKind.Complete">
            <summary>
            Complete analysis that tracks <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue"/> for all <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisResult">
            <summary>
            Analysis result from execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/> on a control flow graph.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.TrackedEntitiesBuilder">
            <summary>
            Stores all the <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>s and <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue"/>s that got tracked during points to analysis
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.TrackedEntitiesBuilder.AllEntities">
            <summary>
            Stores all the tracked entities.
            NOTE: Entities added to this set should not be removed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.TrackedEntitiesBuilder.PointsToValues">
            <summary>
            Stores all the tracked <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue"/> that some entity from <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.TrackedEntitiesBuilder.AllEntities"/>
            points to during points to analysis.
            NOTE: Values added to this set should not be removed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisContext">
            <summary>
            Analysis context for execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/> on a control flow graph.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.DefaultPointsToValueGenerator">
            <summary>
            Generates and stores the default <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue"/> for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances generated for member and element reference operations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.NullAbstractValue">
            <summary>
            Abstract null value for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>/<see cref="T:Microsoft.CodeAnalysis.IOperation"/> tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue">
            <summary>
            Abstract PointsTo value for an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>/<see cref="T:Microsoft.CodeAnalysis.IOperation"/> tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/>.
            It contains the set of possible <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation"/>s that the entity or the operation can point to and the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue.Kind"/> of the location(s).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind">
            <summary>
            Kind for the <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind.Invalid">
            <summary>
            Invalid value based on predicate analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind.Undefined">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind.KnownLocations">
            <summary>
            Points to one or more known possible locations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind.KnownLValueCaptures">
            <summary>
            Points to one or more known possible l-values.
            Used for pointers, ref expressions and l-value flow captures.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind.UnknownNull">
            <summary>
            Points to unknown set of locations, which is known to be null.
            Note that this value kind is theoretically not needed, as the underlying
            value is null, but it has been added to ensure monotonicity of value merge.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind.UnknownNotNull">
            <summary>
            Points to unknown set of locations, which is known to be non-null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind.Unknown">
            <summary>
            Points to unknown set of locations, which may or may not be null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis">
            <summary>
            Dataflow analysis to track locations pointed to by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> and <see cref="T:Microsoft.CodeAnalysis.IOperation"/> instances.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis.CorePointsToAnalysisDataDomain">
            <summary>
            An abstract analysis domain implementation for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData`2"/> tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis.NullAbstractValueDomain">
            <summary>
            Abstract value domain to merge and compare <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.NullAbstractValue"/> values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis.PointsToAbstractValueDomain">
            <summary>
            Abstract value domain for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/> to merge and compare <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue"/> values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis.PointsToAnalysisDomain">
            <summary>
            An abstract analysis domain implementation for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisData"/> tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis.PointsToDataFlowOperationVisitor">
            <summary>
            Operation visitor to flow the PointsTo values across a given statement in a basic block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis.PointsToDataFlowOperationVisitor.IsSpecialFactoryMethodReturningNonNullValue(Microsoft.CodeAnalysis.IMethodSymbol,Analyzer.Utilities.WellKnownTypeProvider)">
            <summary>
            Returns true if this special static factory method whose name starts with "Create", such that
            method's return type is not nullable, i.e. 'type?', and
            method's containing type is static OR a special type OR derives from or is same as the type of the field/property/method return.
            For example: class SomeType { static SomeType CreateXXX(...); }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis.PointsToDataFlowOperationVisitor.IsSpecialEmptyMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if this special member symbol named "Empty", such that one of the following is true:
             1. It is a static method with no parameters or
             2. It is a static readonly property or
             3. It is static readonly field
            and symbol's containing type is a special type or derives from or is same as the type of the field/property/method return.
            For example:
             1. class SomeType { static readonly SomeType Empty; }
             2. class SomeType { static readonly SomeType Empty { get; } }
             3. class SomeType { static SomeType Empty(); }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisData">
            <summary>
            Aggregated PointsTo analysis data tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/>.
            Contains the <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData`2"/> for entity PointsTo values and
            the predicated values based on true/false runtime values of predicated entities.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToBlockAnalysisResult">
            <summary>
            Result from execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/> on a basic block.
            It stores the PointsTo value for each <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> at the start and end of the basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.LambdaAndLocalFunctionAnalysisInfo">
            <summary>
            Contains information about escaped and analyzed lambda methods and local functions
            in context of analyzing its containing method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.LambdaAndLocalFunctionAnalysisInfo.EscapedLocalFunctions">
            <summary>
            Local functions that escaped analysis scope of the containing method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.LambdaAndLocalFunctionAnalysisInfo.AnalyzedLocalFunctions">
            <summary>
            Local functions for which interprocedural analysis was performed at least once during analysis of the containing method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.LambdaAndLocalFunctionAnalysisInfo.EscapedLambdas">
            <summary>
            Lambda methods that escaped analysis scope of the containing method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.LambdaAndLocalFunctionAnalysisInfo.AnalyzedLambdas">
            <summary>
            Lambda methods for which interprocedural analysis was performed at least once during analysis of the containing method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicateAnalysisEntityDataFlowOperationVisitor`4">
            <summary>
            Predicate analysis based Operation visitor to flow the abstract dataflow analysis values for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances across a given statement in a basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysisContext">
            <summary>
            Analysis context for execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis"/> on a control flow graph.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValue">
            <summary>
            Abstract dispose data tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis"/>.
            It contains the set of <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s that dispose an associated disposable <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation"/> and
            the dispose <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValue.Kind"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind">
            <summary>
            Abstract dispose value for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation"/>/<see cref="T:Microsoft.CodeAnalysis.IOperation"/> tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind.NotDisposable">
            <summary>
            Indicates locations that are not disposable, e.g. value types, constants, etc.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind.Invalid">
            <summary>
            Indicates a value for disposable locations that are not feasible on the given program path.
            For example,
            <code>
                var x = flag ? new Disposable() : null;
                if (x == null)
                {
                    // Disposable allocation above cannot exist on this code path.
                }
            </code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind.NotDisposed">
            <summary>
            Indicates disposable locations that are not disposed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind.Escaped">
            <summary>
            Indicates disposable locations that have escaped the declaring method's scope.
            For example, a disposable allocation assigned to a field/property or
            escaped as a return value for a function, or assigned to a ref or out parameter, etc.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind.NotDisposedOrEscaped">
            <summary>
            Indicates disposable locations that are either not disposed or escaped.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind.Disposed">
            <summary>
            Indicates disposable locations that are disposed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind.MaybeDisposed">
            <summary>
            Indicates disposable locations that may be disposed on some program path(s).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind.Unknown">
            <summary>
            Indicates disposable locations whose dispose state is unknown.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis">
            <summary>
            Dataflow analysis to track dispose state of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation"/>/<see cref="T:Microsoft.CodeAnalysis.IOperation"/> instances.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis.DisposeAbstractValueDomain">
            <summary>
            Abstract value domain for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis"/> to merge and compare <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValue"/> values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis.DisposeDataFlowOperationVisitor">
            <summary>
            Operation visitor to flow the dispose values across a given statement in a basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeBlockAnalysisResult">
            <summary>
            Result from execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis"/> on a basic block.
            It store dispose values for each <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation"/> at the start and end of the basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysisResult">
            <summary>
            Analysis result from execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis"/> on a control flow graph.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysisContext">
            <summary>
            Analysis context for execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis"/> on a control flow graph.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis">
            <summary>
            Dataflow analysis to track value content of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>/<see cref="T:Microsoft.CodeAnalysis.IOperation"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis.ValueContentAnalysisDomain">
            <summary>
            An abstract analysis domain implementation for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysisData"/> tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis.CoreAnalysisDataDomain">
            <summary>
            An abstract analysis domain implementation for core analysis data tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis.ValueContentAbstractValueDomain">
            <summary>
            Abstract value domain for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis"/> to merge and compare <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue"/> values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis.ValueContentDataFlowOperationVisitor">
            <summary>
            Operation visitor to flow the data values across a given statement in a basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContainsNonLiteralState">
            <summary>
            Value state for presence of non-literal values for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>/<see cref="T:Microsoft.CodeAnalysis.IOperation"/> tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContainsNonLiteralState.Invalid">
            <summary>The variable state is invalid due to predicate analysis.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContainsNonLiteralState.Undefined">
            <summary>State is undefined.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContainsNonLiteralState.No">
            <summary>The variable does not contain any instances of a non-literal.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContainsNonLiteralState.Maybe">
            <summary>The variable may or may not contain instances of a non-literal.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue">
            <summary>
            Abstract value content data value for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>/<see cref="T:Microsoft.CodeAnalysis.IOperation"/> tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue.NonLiteralState">
            <summary>
            Indicates if this variable contains non literal operands or not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue.LiteralValues">
            <summary>
            Gets a collection of the literals that could possibly make up the contents of this abstract value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue.Merge(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue)">
            <summary>
            Performs the union of this state and the other state 
            and returns a new <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue"/> with the result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue.TryGetSingleNonNullLiteral``1(``0@)">
            <summary>
            For super simple cases: If this abstract value is a single non-null literal, then get that literal value.
            </summary>
            <typeparam name="T">Type of the expected literal value.</typeparam>
            <param name="literalValue">Literal value, or its default if not a single non-null literal value.</param>
            <returns>True if a non-null literal value was found, false otherwise.</returns>
            <remarks>If you're looking for null, you should be looking at <see cref="N:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis"/>.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue.MergeBinaryOperation(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue,Microsoft.CodeAnalysis.Operations.BinaryOperatorKind,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Performs the union of this state and the other state for a Binary operation
            and returns a new <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue"/> with the result.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysisData">
            <summary>
            Aggregated value content analysis data tracked by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis"/>.
            Contains the <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData`2"/> for entity data values and
            the predicated values based on true/false runtime values of predicated entities.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentBlockAnalysisResult">
            <summary>
            Result from execution of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis"/> on a basic block.
            It stores data values for each <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> at the start and end of the basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractAnalysisDomain`1">
            <summary>
            Abstract analysis domain for a <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/> to merge and compare analysis data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractAnalysisDomain`1.Clone(`0)">
            <summary>
            Creates a clone of the analysis data.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractAnalysisDomain`1.Merge(`0,`0)">
            <summary>
            Returns a value that is greater than <paramref name="value1"/> and <paramref name="value2"/>.
            </summary>
            <param name="value1">A value to be merged</param>
            <param name="value2">A value to be merged</param>
            <returns>A value that is greater than <paramref name="value1"/> and <paramref name="value2"/></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractAnalysisDomain`1.Compare(`0,`0)">
             <summary>
             Compares <paramref name="oldValue"/> with <paramref name="newValue"/>
             and returns a value indicating whether one value is less than,
             equal to, or greater than the other.
             </summary>
             <param name="oldValue">A value to compare</param>
             <param name="newValue">A value to compare</param>
             <returns>A signed integer that indicates the relative values of
             <paramref name="oldValue"/> and <paramref name="newValue"/>.
             <para>Less than zero: <paramref name="oldValue"/> is less than <paramref name="newValue"/>.</para>
             <para>Zero: <paramref name="oldValue"/> equals <paramref name="newValue"/>.</para>
             <para>Greater than zero: <paramref name="oldValue"/> is greater than <paramref name="newValue"/>.</para>
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractAnalysisDomain`1.Equals(`0,`0)">
            <summary>
            Indicates if <paramref name="value1"/> with <paramref name="value2"/> are equal.
            </summary>
            <param name="value1">A value to compare</param>
            <param name="value2">A value to compare</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractBlockAnalysisResult">
            <summary>
            Result from execution of a <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/> on a basic block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisPredicate">
            <summary>
            Interprocedural analysis predicate to decide whether interprocedural analysis can be skipped.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisConfiguration">
            <summary>
            Interprocedural analysis configuration parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisConfiguration.DefaultMaxInterproceduralMethodCallChain">
            <summary>
            Defines the max length for method call chain (call stack size) for interprocedural analysis.
            This is done for performance reasons for analyzing methods with extremely large call trees.
            https://github.com/dotnet/roslyn-analyzers/issues/1809 tracks improving this heuristic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisConfiguration.DefaultMaxInterproceduralLambdaOrLocalFunctionCallChain">
            <summary>
            Defines the max length for lambda/local function method call chain (call stack size) for interprocedural analysis.
            This is done for performance reasons for analyzing methods with extremely large call trees.
            https://github.com/dotnet/roslyn-analyzers/issues/1809 tracks improving this heuristic.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ConversionInference">
            <summary>
            Conversion inference result.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralCaptureId">
            <summary>
            Unique flow capture Id across interprocedural flow graph.
            This type essentially wraps each <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId"/>, which is unique for each control flow graph,
            with its owning <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralCaptureId.ControlFlowGraph"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ArgumentInfo`1">
            <summary>
            Contains information about an argument passed to interprocedural analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind">
            <summary>
            Determines the kind of interprocedural dataflow analysis to perform for method invocations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind.None">
            <summary>
            Skip interprocedural analysis for source method invocations, except for lambda and location function invocations,
            which are always analyzed in a context sensitive fashion.
            All the analysis data for invocation receiver and arguments is conservatively reset at call sites.
            Produces least precise results from amongst the possible interprocedural modes, but is the most performant mode.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind.ContextSensitive">
            <summary>
            Performs context sensitive interprocedural analysis for all source method invocations,
            including lambda and location function invocations.
            Context sensitive interprocedural analysis analyzes invoked method at each call site by considering the calling context,
            i.e. the argument values and instance receiver, hence is the most precise analysis mode.
            This mode is also the most performance intensive mode.
            Note that we apply a max threshold to the length of interprocedural call chain to analyze in
            a context sensitive fashion to avoid infinite computation for huge call graphs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisData`3">
            <summary>
            Contains the caller's analysis context data passed to context sensitive interprocedural analysis, <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind.ContextSensitive"/>.
            This includes the following:
            1. Caller's tracked analysis data at the call site, which is the initial analysis data for callee.
            2. Information about the invocation instance on which the method is invoked.
            3. Information about arguments for the invocation.
            4. Captured variables (for lambda/local function invocations).
            5. Information about ref/out parameter entities that share address with callee's parameters.
            6. Operation call stack for the current interprocedural analysis.
            7. Set of analysis contexts currently being analyzed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult`1">
            <summary>
            Marker interface for analysis results from execution of <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/> on a control flow graph.
            Primarily exists for specifying constraints on analysis result type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisContext">
            <summary>
            Marker interface for analysis contexts for execution of <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/> on a control flow graph.
            Primarily exists for specifying constraints on analysis context type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDataFlowAnalysisContext`4">
            <summary>
            Base type for analysis contexts for execution of <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/> on a control flow graph.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDomain`1">
            <summary>
            Abstract domain for a <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/> to merge and compare values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDomain`1.Bottom">
            <summary>
            Returns the minor value of the domain.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDomain`1.Merge(`0,`0)">
            <summary>
            Returns a value that is greater than <paramref name="value1"/> and <paramref name="value2"/>.
            </summary>
            <param name="value1">A value to be merged</param>
            <param name="value2">A value to be merged</param>
            <returns>A value that is greater than <paramref name="value1"/> and <paramref name="value2"/></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDomain`1.Compare(`0,`0)">
             <summary>
             Compares <paramref name="oldValue"/> with <paramref name="newValue"/>
             and returns a value indicating whether one value is less than,
             equal to, or greater than the other.
             </summary>
             <param name="oldValue">A value to compare</param>
             <param name="newValue">A value to compare</param>
             <returns>A signed integer that indicates the relative values of
             <paramref name="oldValue"/> and <paramref name="newValue"/>.
             <para>Less than zero: <paramref name="oldValue"/> is less than <paramref name="newValue"/>.</para>
             <para>Zero: <paramref name="oldValue"/> equals <paramref name="newValue"/>.</para>
             <para>Greater than zero: <paramref name="oldValue"/> is greater than <paramref name="newValue"/>.</para>
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDomain`1.Equals(`0,`0)">
            <summary>
            Indicates if <paramref name="value1"/> and <paramref name="value2"/> are equal.
            </summary>
            <param name="value1">A value to compare</param>
            <param name="value2">A value to compare</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CacheBasedEquatable`1">
            <summary>
            Abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractIndex">
            <summary>
            Represents an abstract index into a location.
            It is used by an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> for operations such as an <see cref="T:Microsoft.CodeAnalysis.Operations.IArrayElementReferenceOperation"/>, index access <see cref="T:Microsoft.CodeAnalysis.Operations.IPropertyReferenceOperation"/>, etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation">
            <summary>
            <para>
            Represents an abstract analysis location.
            This is may be used to represent a location where an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> resides, i.e. <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.InstanceLocation"/> or
            a location that is pointed to by a reference type variable, and tracked with <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis"/>.
            </para>
            <para>
            An analysis location can be created for one of the following cases:
                1. An allocation or an object creation operation (<see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.CreateAllocationLocation(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisContext)"/>).
                2. Location for the implicit 'this' or 'Me' instance being analyzed (<see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.CreateThisOrMeLocation(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableStack{Microsoft.CodeAnalysis.IOperation})"/>).
                3. Location created for certain symbols which do not have a declaration in executable code, i.e. no <see cref="T:Microsoft.CodeAnalysis.IOperation"/> for declaration (such as parameter symbols, member symbols, etc. - <see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.CreateSymbolLocation(Microsoft.CodeAnalysis.ISymbol,System.Collections.Immutable.ImmutableStack{Microsoft.CodeAnalysis.IOperation})"/>/>).
                4. Location created for flow capture entities, i.e. for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralCaptureId"/> created for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/> or <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureReferenceOperation"/>.
                   See <see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.CreateFlowCaptureLocation(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralCaptureId,Microsoft.CodeAnalysis.ITypeSymbol,System.Collections.Immutable.ImmutableStack{Microsoft.CodeAnalysis.IOperation})"/>
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.GetTopOfCreationCallStackOrCreation">
            <summary>
            Returns the top of <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.CreationCallStack"/> if this location was created through an interprocedural method invocation, i.e. <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.CreationCallStack"/> is non-empty.
            Otherwise, returns <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.Creation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.IsAnalysisEntityDefaultLocation">
            <summary>
            Indicates this represents the initial unknown but distinct location for an analysis entity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation.TryGetNodeToReportDiagnostic(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisResult)">
            <summary>
            Attempts to get the syntax node to report diagnostic for this abstract location
            Returns null if the location is owned by another method invoked through interprocedural analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocationDataFlowOperationVisitor`4">
            <summary>
            Operation visitor to flow the abstract dataflow analysis values for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation"/>s across a given statement in a basic block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocationDataFlowOperationVisitor`4.ResetAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation,`3})">
            <summary>
            Helper method to reset analysis data for analysis locations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractValueDomain`1">
            <summary>
            Abstract value domain for a <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/> to merge and compare values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractValueDomain`1.UnknownOrMayBeValue">
            <summary>
            Returns the major Unknown or MayBe top value of the domain.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity">
            <summary>
            <para>
            Primary entity for which analysis data is tracked by <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/>.
            </para>
            <para>
            The entity is based on one or more of the following:
                1. An <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.
                2. One or more <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractIndex"/> indices to index into the parent key.
                3. "this" or "Me" instance.
                4. An allocation or an object creation.
            </para>
            <para>
            Each entity has:
                1. An associated non-null <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.Type"/> and
                2. A non-null <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.InstanceLocation"/> indicating the abstract location at which the entity is located and
                3. An optional parent key if this key has the same <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.InstanceLocation"/> as the parent (i.e. parent is a value type).
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityBasedPredicateAnalysisData`1">
            <summary>
            Base class for all the aggregate analysis data with predicated analysis data,
            whose <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityBasedPredicateAnalysisData`1.CoreAnalysisData"/> is keyed by an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4">
            <summary>
            Operation visitor to flow the abstract dataflow analysis values for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances across a given statement in a basic block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4.ResetAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,`3})">
            <summary>
            Helper method to reset analysis data for analysis entities.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4.ResetValueTypeInstanceAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity)">
            <summary>
            Resets all the analysis data for all <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances that share the same <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.InstanceLocation"/>
            as the given <paramref name="analysisEntity"/>.
            </summary>
            <param name="analysisEntity"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4.ResetInstanceAnalysisDataCore(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity})">
            <summary>
            Resets the analysis data for the given <paramref name="dependantAnalysisEntities"/>.
            </summary>
            <param name="dependantAnalysisEntities"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4.TransferValueTypeInstanceAnalysisDataForAssignment(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Transfers the analysis data rooted from <paramref name="valueAnalysisEntity"/> or <paramref name="assignedValueOperation"/> to <paramref name="targetAnalysisEntity"/>, for a value type assignment operation.
            This involves transfer of data for of all <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances that share the same <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.InstanceLocation"/> as <paramref name="valueAnalysisEntity"/> or allocation for the <paramref name="assignedValueOperation"/>
            to all <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances that share the same <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.InstanceLocation"/> as <paramref name="targetAnalysisEntity"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4.GetTrimmedCurrentAnalysisData(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity})">
            <summary>
            Returns a cloned CurrentAnalysisData, trimmed down to only have key-value pairs for the given <paramref name="withEntities"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityFactory">
            <summary>
            Factory to create <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> objects for operations, symbol declarations, etc.
            This factory also tracks analysis entities that share the same instance location (e.g. value type members).
            NOTE: This factory must only be used from within an <see cref="T:Microsoft.CodeAnalysis.Operations.OperationVisitor"/>, as it is tied to the visitor's state tracking via <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityFactory._getIsInsideAnonymousObjectInitializer"/> delegate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityMapAbstractDomain`1">
            <summary>
            An abstract domain implementation for analyses that store dictionary typed data.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysis`5">
            <summary>
            Subtype for all dataflow analyses on a control flow graph.
            It performs a worklist based approach to flow abstract data values for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>/<see cref="T:Microsoft.CodeAnalysis.IOperation"/> across the basic blocks until a fix point is reached.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysisResult`2">
            <summary>
            Result from execution of a <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/> on a control flow graph.
            It stores:
             (1) Analysis values for all operations in the graph and
             (2) <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractBlockAnalysisResult"/> for every basic block in the graph.
             (3) Merged analysis state for all the unhandled throw operations in the graph.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysisResultBuilder`1">
            <summary>
            Used by <see cref="T:Microsoft.CodeAnalysis.DataFlowAnalysis"/> to store intermediate dataflow results while executing data flow analysis
            and also to compute the final <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysisResult`2"/> exposed as the result.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4">
            <summary>
            Operation visitor to flow the abstract dataflow analysis values across a given statement in a basic block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4._escapedLocalFunctions">
            <summary>
            Local functions that escaped from this method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4._analyzedLocalFunctions">
            <summary>
            Local functions for which interprocedural analysis was performed at least once in this method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4._escapedLambdas">
            <summary>
            Lambda methods that escaped from this method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4._analyzedLambdas">
            <summary>
            Lambda methods for which interprocedural analysis was performed at least once in this method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.MaxInterproceduralMethodCallChain">
            <summary>
            Defines the max length for method call chain (call stack size) for interprocedural analysis.
            This is done for performance reasons for analyzing methods with extremely large call trees.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.MaxInterproceduralLambdaOrLocalFunctionCallChain">
            <summary>
            Defines the max length for lambda/local function method call chain (call stack size) for interprocedural analysis.
            This is done for performance reasons for analyzing methods with extremely large call trees.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4._addressSharedEntitiesProvider">
            <summary>
            Stores a map from entity to set of entities that share the same instance location.
            Primarily used for ref arguments for context sensitive interprocedural analysis
            to ensure that PointsTo value updates to any of the mapped entities is reflected in the others in the set.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4._interproceduralCallStack">
            <summary>
            Current interprocedural operation call stack.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4._interproceduralResultsBuilder">
            <summary>
            Dictionary storing context sensitive interprocedural analysis results for each callsite.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4._standaloneLocalFunctionAnalysisResultsBuilder">
            <summary>
            Dictionary storing context insensitive interprocedural analysis results for escaped local function.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4._interproceduralMethodToCfgMap">
            <summary>
            Dictionary from interprocedural method symbols invoked to their corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.HasPointsToAnalysisResult">
            <summary>
            Indicates if we have any points to analysis data, with or without tracking for fields and properties, i.e. either
            <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisKind.PartialWithoutTrackingFieldsAndProperties"/> or <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisKind.Complete"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.HasCompletePointsToAnalysisResult">
            <summary>
            Indicates if we have complete points to analysis data with <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisKind.Complete"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.TaskWrappedValuesMap">
            <summary>
            Optional map from points to values of tasks to the underlying abstract value returned by the task.
            Awaiting the task produces the task wrapped value from this map.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.PessimisticAnalysis">
            <summary>
            This boolean field determines if the caller requires an optimistic OR a pessimistic analysis for such cases.
            For example, invoking an instance method may likely invalidate all the instance field analysis state, i.e.
            reference type fields might be re-assigned to point to different objects in the called method.
            An optimistic points to analysis assumes that the points to values of instance fields don't change on invoking an instance method.
            A pessimistic points to analysis resets all the instance state and assumes the instance field might point to any object, hence has unknown state.
            </summary>
            <remarks>
            For dispose analysis, we want to perform an optimistic points to analysis as we assume a disposable field is not likely to be re-assigned to a separate object in helper method invocations in Dispose.
            For value content analysis, we want to perform a pessimistic points to analysis to be conservative and avoid missing out true violations.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.PredicateAnalysis">
            <summary>
            Indicates if we this visitor needs to analyze predicates of conditions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.IsInsideAnonymousObjectInitializer">
            <summary>
            PERF: Track if we are within an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousObjectCreationOperation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.Flow(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0)">
            <summary>
            Primary method that flows analysis data through the given statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.UpdateValuesForAnalysisData(`0)">
            <summary>
            Updates values for existing entries in <paramref name="targetAnalysisData"/> with newer values from CurrentAnalysisData.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.UpdateValuesForAnalysisData``1(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData{``0,`3},Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData{``0,`3})">
            <summary>
            Helper method to update analysis data for existing entries in <paramref name="targetAnalysisData"/>
            with newer values from <paramref name="newAnalysisData"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.FlowBranch(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,Microsoft.CodeAnalysis.FlowAnalysis.BranchWithInfo,`0)">
            <summary>
            Primary method that flows analysis data through the given flow edge/branch.
            Returns false if the branch is conditional and the branch value always evaluates to false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.GetAbstractValueForImplicitWrappingTaskCreation(Microsoft.CodeAnalysis.IOperation,`3,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue)">
            <summary>
            Get analysis value for an implicitly created completed task wrapping a returned value in an async method.
            For example, "return 0;" in an async method returning "Task(Of int)".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.IsAnyDebugAssertMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is an overload of the <see cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/> method.
            </summary>
            <param name="method">The IMethodSymbol to test.</param>
            <returns>True if the method is an overlaod of the <see cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/> method.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.ResetValueTypeInstanceAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity)">
            <summary>
            Resets all the analysis data for all <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances that share the same <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.InstanceLocation"/>
            as the given <paramref name="analysisEntity"/>.
            </summary>
            <param name="analysisEntity"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.ResetReferenceTypeInstanceAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue)">
            <summary>
            Resets all the analysis data for all <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances that share the same <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.InstanceLocation"/>
            as the given <paramref name="pointsToAbstractValue"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.ResetReferenceTypeInstanceAnalysisData(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Resets all the analysis data for all <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> instances that share the same <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity.InstanceLocation"/>
            as pointed to by given reference type <paramref name="operation"/>.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.ResetInstanceAnalysisData(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Reset all the instance analysis data if <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.HasPointsToAnalysisResult"/> is true and <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.PessimisticAnalysis"/> is also true.
            If we are using or performing points to analysis, certain operations can invalidate all the analysis data off the containing instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.GetInitialInterproceduralAnalysisData(Microsoft.CodeAnalysis.IMethodSymbol,System.Nullable{System.ValueTuple{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue}},System.Nullable{System.ValueTuple{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue}},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ArgumentInfo{`3}},System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue},System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue},System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity,Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue},System.Boolean,System.Boolean)">
            <summary>
            Gets a new instance of analysis data that should be passed as initial analysis data
            for interprocedural analysis.
            The default implementation returns cloned CurrentAnalysisData.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.ApplyInterproceduralAnalysisResult(`0,System.Boolean,System.Boolean,`2)">
            <summary>
            Apply the result data from interprocedural analysis to CurrentAnalysisData.
            Default implementation is designed for the default implementation of GetInitialInterproceduralAnalysisData.
            and overwrites the CurrentAnalysisData with the given <paramref name="resultData"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.PostProcessArgument(Microsoft.CodeAnalysis.Operations.IArgumentOperation,System.Boolean)">
            <summary>
            Invoked after the parent invocation/creation operation of the given argument has been visited.
            </summary>
            <param name="operation">Argument to be post-processed.</param>
            <param name="isEscaped">Boolean flag indicating if the argument was escaped due to lack of interprocedural analysis or not.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.PostProcessEscapedArgument(Microsoft.CodeAnalysis.Operations.IArgumentOperation)">
            <summary>
            Post process argument which needs to be escaped/reset after being passed to an invocation/creation target
            without interprocedural analysis.
            This method resets the analysis data for an object instance passed around as an <see cref="T:Microsoft.CodeAnalysis.Operations.IArgumentOperation"/>
            and also handles resetting the argument value for ref/out parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.VisitInvocation_NonLambdaOrDelegateOrLocalFunction(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IOperation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Operations.IArgumentOperation},System.Boolean,Microsoft.CodeAnalysis.IOperation,`3)">
            <summary>
            Visits an invocation, either as a direct method call, or intermediately through a delegate.
            </summary>
            <param name="method">Method that is invoked.</param>
            <param name="visitedInstance">Instance that the method is invoked on, if any.</param>
            <param name="visitedArguments">Arguments to the invoked method.</param>
            <param name="invokedAsDelegate">Indicates that invocation is a delegate invocation.</param>
            <param name="originalOperation">Original invocation operation, which may be a delegate invocation.</param>
            <param name="defaultValue">Default abstract value to return.</param>
            <returns>Abstract value of return value.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.ResetThisOrMeInstanceAnalysisData">
            <summary>
            Reset all the instance analysis data for <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityFactory.ThisOrMeInstance"/> if <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.HasPointsToAnalysisResult"/> is true and <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.PessimisticAnalysis"/> is also true.
            If we are using or performing points to analysis, certain operations can invalidate all the analysis data off the containing instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.ExceptionNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.Exception"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.ContractNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for 'System.Diagnostics.Contracts.Contract' type. />
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.IDisposableNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.IDisposable"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.IAsyncDisposableNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for "System.IAsyncDisposable"
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.TaskNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.Threading.Tasks.Task"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.MemoryStreamNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.IO.MemoryStream"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.ValueTaskNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for System.Threading.Tasks.ValueTask/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.GenericTaskNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.Threading.Tasks.Task`1"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.MonitorNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.Threading.Monitor"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.InterlockedNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.Threading.Interlocked"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.SerializationInfoNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for 'System.Runtime.Serialization.SerializationInfo' type />
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.StreamingContextNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for 'System.Runtime.Serialization.StreamingContext' type />
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.GenericIEquatableNamedType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.IEquatable`1"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.StringReaderType">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.IO.StringReader"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4.CollectionNamedTypes">
            <summary>
            Set containing following named types, if not null:
            1. <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.Collections.ICollection"/>
            2. <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.Collections.Generic.ICollection`1"/>
            3. <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ForwardDataFlowAnalysis`5">
            <summary>
            Subtype for all forward dataflow analyses.
            These analyses operate on the control flow graph starting from the entry block,
            flowing the dataflow values forward to the successor blocks until a fix point is reached.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.LValueFlowCapturesProvider">
            <summary>
            Helper class to detect <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/>s that are l-value captures.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.MapAbstractDomain`2">
            <summary>
            An abstract domain implementation for analyses that store dictionary typed data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.MapAbstractDomain`2.Compare(Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData{`0,`1},Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData{`0,`1})">
            <summary>
            Compares if the abstract dataflow values in <paramref name="oldValue"/> against the values in <paramref name="newValue"/> to ensure
            dataflow function is a monotically increasing function. See https://en.wikipedia.org/wiki/Monotonic_function for understanding monotonic functions.
            </summary>
            <returns>
            1) 0, if both the dictionaries are identical.
            2) -1, if dictionaries are not identical and for every key in <paramref name="oldValue"/>, the corresponding key exists in <paramref name="newValue"/> and
               the value of each such key in <paramref name="oldValue"/> is lesser than or equals the value in <paramref name="newValue"/>.
            3) 1, otherwise.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2">
            <summary>
            Base class for all the predicated analysis data.
            It tracks <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2._lazyPredicateDataMap"/>, which contains the true/false <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2.PerEntityPredicatedAnalysisData"/> for every predicated <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>, and
            <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2.IsReachableBlockData"/>, which tracks if the current data is for a reachable code path based on the predicate analysis.
            Predicate analysis data is used to improve the preciseness of analysis when we can apply the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2.PerEntityPredicatedAnalysisData.TruePredicatedData"/> or <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2.PerEntityPredicatedAnalysisData.FalsePredicatedData"/>
            on the control flow paths where the corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> is known to have <see langword="true"/> or <see langword="false"/> value respectively.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2.PerEntityPredicatedAnalysisData">
            <summary>
            Analysis data predicated by true/false value of an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/>.
            Used to improve the preciseness of analysis when we can apply the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2.PerEntityPredicatedAnalysisData.TruePredicatedData"/> or <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2.PerEntityPredicatedAnalysisData.FalsePredicatedData"/>
            on the control flow paths where the corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> is known to have <see langword="true"/> or <see langword="false"/> value respectively.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2.PerEntityPredicatedAnalysisData.TruePredicatedData">
            <summary>
            Analysis data for <see langword="true"/> value of the corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> on which this data is predicated.
            <see langword="null"/> value indicates the corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> can never be <see langword="true"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2.PerEntityPredicatedAnalysisData.FalsePredicatedData">
            <summary>
            Analysis data for <see langword="false"/> value of the corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> on which this data is predicated.
            <see langword="null"/> value indicates the corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity"/> can never be <see langword="false"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisDataDomain`2">
            <summary>
            An abstract domain implementation for analyses that store dictionary typed data along with predicated data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicateValueKind.AlwaysTrue">
            <summary>
            Predicate always evaluates to true.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicateValueKind.AlwaysFalse">
            <summary>
            Predicate always evaluates to false.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicateValueKind.Unknown">
            <summary>
            Predicate might evaluate to true or false.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.StackGuard">
            <summary>
            Stack guard for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4"/> to ensure sufficient stack while recursively visiting the operation tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ThrownExceptionInfo.BasicBlockOrdinal">
            <summary>
            Ordinal of the basic block where this exception is thrown.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ThrownExceptionInfo.HandlingCatchRegion">
            <summary>
            Optional catch handler that handles this exception.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ThrownExceptionInfo.ContainingFinallyRegion">
            <summary>
            If the exception happens within a finally region, this points to that finally.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.BranchWithInfo">
            <summary>
            Contains aggregated information about a control flow branch.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions.IsContainedInRegionOfKind(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind)">
            <summary>
            Returns true if the given <paramref name="basicBlock"/> is contained in a control flow region with the given <paramref name="regionKind"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions.GetContainingRegionOfKind(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind)">
            <summary>
            Returns the innermost control flow region of the given <paramref name="regionKind"/> that contains the given <paramref name="basicBlock"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions.IsFirstBlockOfFinally(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion@)">
            <summary>
            Returns true if the given basic block is the first block of a finally region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions.IsLastBlockOfFinally(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion@)">
            <summary>
            Returns true if the given basic block is the last block of a finally region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions.IsFirstBlockOfRegionKind(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion@)">
            <summary>
            Returns true if the given basic block is the first block of a region of the given regionKind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions.IsLastBlockOfRegionKind(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion@)">
            <summary>
            Returns true if the given basic block is the last block of a region of the given regionKind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions.IsFirstBlockOfCompilerGeneratedFinally(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph)">
            <summary>
            Returns true if the given basic block is the first block of a compiler generated finally region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions.GetMaxSuccessorOrdinal(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock)">
            <summary>
            Gets the maximum ordinal of a conditional or fall through successor of the given basic block.
            Returns -1 if the block has no conditional or fall through successor,
            for example, if the block only has a structured exception handling branch for throw operation.
            </summary>
            <param name="basicBlock"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Utilities.PerformanceSensitiveAttribute">
            <summary>
            Indicates that a code element is performance sensitive under a known scenario.
            </summary>
            <remarks>
            <para>When applying this attribute, only explicitly set the values for properties specifically indicated by the
            test/measurement technique described in the associated <see cref="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri">
            <summary>
            Gets the location where the original problem is documented, likely with steps to reproduce the issue and/or
            validate performance related to a change in the method.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Constraint">
            <summary>
            Gets or sets a description of the constraint imposed by the original performance issue.
            </summary>
            <remarks>
            <para>Constraints are normally specified by other specific properties that allow automated validation of the
            constraint. This property supports documenting constraints which cannot be described in terms of other
            constraint properties.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowCaptures">
            <summary>
            Gets or sets a value indicating whether captures are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowImplicitBoxing">
            <summary>
            Gets or sets a value indicating whether implicit boxing of value types is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration">
            <summary>
            Gets or sets a value indicating whether enumeration of a generic
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowLocks">
            <summary>
            Gets or sets a value indicating whether locks are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously">
            <summary>
            Gets or sets a value indicating whether the asynchronous state machine typically completes synchronously.
            </summary>
            <remarks>
            <para>When <see langword="true"/>, validation of this performance constraint typically involves analyzing
            the method to ensure synchronous completion of the state machine does not require the allocation of a
            <see cref="T:System.Threading.Tasks.Task"/>, either through caching the result or by using
            <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.IsParallelEntry">
            <summary>
            Gets or sets a value indicating whether this is an entry point to a parallel algorithm.
            </summary>
            <remarks>
            <para>Parallelization APIs and algorithms, e.g. <c>Parallel.ForEach</c>, may be efficient for parallel entry
            points (few direct calls but large amounts of iterative work), but are problematic when called inside the
            iterations themselves. Performance-sensitive code should avoid the use of heavy parallelization APIs except
            for known entry points to the parallel portion of code.</para>
            </remarks>
        </member>
    </members>
</doc>
